// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/api.proto
// Protobuf C++ Version: 6.33.1

#ifndef protos_2fapi_2eproto_2epb_2eh
#define protos_2fapi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fapi_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fapi_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_protos_2fapi_2eproto;
}  // extern "C"
enum ComponentType : int;
extern const uint32_t ComponentType_internal_data_[];
enum MessageType : int;
extern const uint32_t MessageType_internal_data_[];
class AddComponent;
struct AddComponentDefaultTypeInternal;
extern AddComponentDefaultTypeInternal _AddComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AddComponent_class_data_;
class AddVoxels;
struct AddVoxelsDefaultTypeInternal;
extern AddVoxelsDefaultTypeInternal _AddVoxels_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AddVoxels_class_data_;
class ApiRequest;
struct ApiRequestDefaultTypeInternal;
extern ApiRequestDefaultTypeInternal _ApiRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ApiRequest_class_data_;
class ApiRequestResponse;
struct ApiRequestResponseDefaultTypeInternal;
extern ApiRequestResponseDefaultTypeInternal _ApiRequestResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ApiRequestResponse_class_data_;
class ClearVoxels;
struct ClearVoxelsDefaultTypeInternal;
extern ClearVoxelsDefaultTypeInternal _ClearVoxels_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ClearVoxels_class_data_;
class Component;
struct ComponentDefaultTypeInternal;
extern ComponentDefaultTypeInternal _Component_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Component_class_data_;
class ConfirmAction;
struct ConfirmActionDefaultTypeInternal;
extern ConfirmActionDefaultTypeInternal _ConfirmAction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConfirmAction_class_data_;
class CreateEntity;
struct CreateEntityDefaultTypeInternal;
extern CreateEntityDefaultTypeInternal _CreateEntity_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CreateEntity_class_data_;
class DeleteComponent;
struct DeleteComponentDefaultTypeInternal;
extern DeleteComponentDefaultTypeInternal _DeleteComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteComponent_class_data_;
class DeleteEntity;
struct DeleteEntityDefaultTypeInternal;
extern DeleteEntityDefaultTypeInternal _DeleteEntity_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeleteEntity_class_data_;
class EditComponent;
struct EditComponentDefaultTypeInternal;
extern EditComponentDefaultTypeInternal _EditComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EditComponent_class_data_;
class EngineStatus;
struct EngineStatusDefaultTypeInternal;
extern EngineStatusDefaultTypeInternal _EngineStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EngineStatus_class_data_;
class EntityComponentInfo;
struct EntityComponentInfoDefaultTypeInternal;
extern EntityComponentInfoDefaultTypeInternal _EntityComponentInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EntityComponentInfo_class_data_;
class GetComponent;
struct GetComponentDefaultTypeInternal;
extern GetComponentDefaultTypeInternal _GetComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetComponent_class_data_;
class KeyReplay;
struct KeyReplayDefaultTypeInternal;
extern KeyReplayDefaultTypeInternal _KeyReplay_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull KeyReplay_class_data_;
class KeyReplayEntry;
struct KeyReplayEntryDefaultTypeInternal;
extern KeyReplayEntryDefaultTypeInternal _KeyReplayEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull KeyReplayEntry_class_data_;
class ListEntities;
struct ListEntitiesDefaultTypeInternal;
extern ListEntitiesDefaultTypeInternal _ListEntities_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ListEntities_class_data_;
class ModelComponent;
struct ModelComponentDefaultTypeInternal;
extern ModelComponentDefaultTypeInternal _ModelComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ModelComponent_class_data_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Move_class_data_;
class NoPayload;
struct NoPayloadDefaultTypeInternal;
extern NoPayloadDefaultTypeInternal _NoPayload_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NoPayload_class_data_;
class PlayerMove;
struct PlayerMoveDefaultTypeInternal;
extern PlayerMoveDefaultTypeInternal _PlayerMove_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerMove_class_data_;
class PointerReplay;
struct PointerReplayDefaultTypeInternal;
extern PointerReplayDefaultTypeInternal _PointerReplay_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointerReplay_class_data_;
class PointerReplayEntry;
struct PointerReplayEntryDefaultTypeInternal;
extern PointerReplayEntryDefaultTypeInternal _PointerReplayEntry_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PointerReplayEntry_class_data_;
class PositionableComponent;
struct PositionableComponentDefaultTypeInternal;
extern PositionableComponentDefaultTypeInternal _PositionableComponent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionableComponent_class_data_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Range_class_data_;
class TurnKey;
struct TurnKeyDefaultTypeInternal;
extern TurnKeyDefaultTypeInternal _TurnKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TurnKey_class_data_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Vector_class_data_;
class VoxelCoord;
struct VoxelCoordDefaultTypeInternal;
extern VoxelCoordDefaultTypeInternal _VoxelCoord_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VoxelCoord_class_data_;
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::ComponentType_internal_data_>
    internal::EnumTraitsImpl::value<::ComponentType>;
template <>
internal::EnumTraitsT<::MessageType_internal_data_>
    internal::EnumTraitsImpl::value<::MessageType>;
}  // namespace protobuf
}  // namespace google

enum MessageType : int {
  MOVE = 0,
  TURN_KEY = 1,
  PLAYER_MOVE = 2,
  UNFOCUS_WINDOW = 3,
  ADD_VOXELS = 4,
  CLEAR_VOXELS = 5,
  CONFIRM_ACTION = 6,
  QUIT = 7,
  KEY_REPLAY = 8,
  STATUS = 9,
  POINTER_REPLAY = 10,
  ADD_COMPONENT = 11,
  DELETE_COMPONENT = 12,
  EDIT_COMPONENT = 13,
  CREATE_ENTITY = 14,
  DELETE_ENTITY = 15,
  LIST_ENTITIES = 16,
  GET_COMPONENT = 17,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MessageType_internal_data_[];
inline constexpr MessageType MessageType_MIN =
    static_cast<MessageType>(0);
inline constexpr MessageType MessageType_MAX =
    static_cast<MessageType>(17);
inline bool MessageType_IsValid(int value) {
  return 0 <= value && value <= 17;
}
inline constexpr int MessageType_ARRAYSIZE = 17 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MessageType_descriptor();
template <typename T>
const ::std::string& MessageType_Name(T value) {
  static_assert(::std::is_same<T, MessageType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor, 0, 17>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(
    ::absl::string_view name, MessageType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(MessageType_descriptor(), name,
                                           value);
}
enum ComponentType : int {
  COMPONENT_TYPE_UNSPECIFIED = 0,
  COMPONENT_TYPE_POSITIONABLE = 1,
  COMPONENT_TYPE_MODEL = 2,
  ComponentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ComponentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ComponentType_internal_data_[];
inline constexpr ComponentType ComponentType_MIN =
    static_cast<ComponentType>(0);
inline constexpr ComponentType ComponentType_MAX =
    static_cast<ComponentType>(2);
inline bool ComponentType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ComponentType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ComponentType_descriptor();
template <typename T>
const ::std::string& ComponentType_Name(T value) {
  static_assert(::std::is_same<T, ComponentType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ComponentType_Name().");
  return ComponentType_Name(static_cast<ComponentType>(value));
}
template <>
inline const ::std::string& ComponentType_Name(ComponentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComponentType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ComponentType_Parse(
    ::absl::string_view name, ComponentType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComponentType>(ComponentType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class VoxelCoord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VoxelCoord) */ {
 public:
  inline VoxelCoord() : VoxelCoord(nullptr) {}
  ~VoxelCoord() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VoxelCoord* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VoxelCoord));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VoxelCoord(::google::protobuf::internal::ConstantInitialized);

  inline VoxelCoord(const VoxelCoord& from) : VoxelCoord(nullptr, from) {}
  inline VoxelCoord(VoxelCoord&& from) noexcept
      : VoxelCoord(nullptr, ::std::move(from)) {}
  inline VoxelCoord& operator=(const VoxelCoord& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoxelCoord& operator=(VoxelCoord&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoxelCoord& default_instance() {
    return *reinterpret_cast<const VoxelCoord*>(
        &_VoxelCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(VoxelCoord& a, VoxelCoord& b) { a.Swap(&b); }
  inline void Swap(VoxelCoord* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoxelCoord* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoxelCoord* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VoxelCoord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VoxelCoord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VoxelCoord& from) { VoxelCoord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VoxelCoord* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "VoxelCoord"; }

  explicit VoxelCoord(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VoxelCoord(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VoxelCoord& from);
  VoxelCoord(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VoxelCoord&& from) noexcept
      : VoxelCoord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:VoxelCoord)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VoxelCoord& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VoxelCoord_class_data_;
// -------------------------------------------------------------------

class Vector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector(::google::protobuf::internal::ConstantInitialized);

  inline Vector(const Vector& from) : Vector(nullptr, from) {}
  inline Vector(Vector&& from) noexcept
      : Vector(nullptr, ::std::move(from)) {}
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *reinterpret_cast<const Vector*>(
        &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector& a, Vector& b) { a.Swap(&b); }
  inline void Swap(Vector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector& from) { Vector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Vector"; }

  explicit Vector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Vector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Vector& from);
  Vector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Vector&& from) noexcept
      : Vector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:Vector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Vector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Vector_class_data_;
// -------------------------------------------------------------------

class TurnKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:TurnKey) */ {
 public:
  inline TurnKey() : TurnKey(nullptr) {}
  ~TurnKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TurnKey* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TurnKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TurnKey(::google::protobuf::internal::ConstantInitialized);

  inline TurnKey(const TurnKey& from) : TurnKey(nullptr, from) {}
  inline TurnKey(TurnKey&& from) noexcept
      : TurnKey(nullptr, ::std::move(from)) {}
  inline TurnKey& operator=(const TurnKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnKey& operator=(TurnKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnKey& default_instance() {
    return *reinterpret_cast<const TurnKey*>(
        &_TurnKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TurnKey& a, TurnKey& b) { a.Swap(&b); }
  inline void Swap(TurnKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnKey* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnKey* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TurnKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TurnKey& from) { TurnKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TurnKey* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "TurnKey"; }

  explicit TurnKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TurnKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TurnKey& from);
  TurnKey(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TurnKey&& from) noexcept
      : TurnKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOnFieldNumber = 2,
  };
  // bool on = 2;
  void clear_on() ;
  bool on() const;
  void set_on(bool value);

  private:
  bool _internal_on() const;
  void _internal_set_on(bool value);

  public:
  // @@protoc_insertion_point(class_scope:TurnKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TurnKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool on_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TurnKey_class_data_;
// -------------------------------------------------------------------

class Range final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Range* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Range));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Range(::google::protobuf::internal::ConstantInitialized);

  inline Range(const Range& from) : Range(nullptr, from) {}
  inline Range(Range&& from) noexcept
      : Range(nullptr, ::std::move(from)) {}
  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *reinterpret_cast<const Range*>(
        &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Range& a, Range& b) { a.Swap(&b); }
  inline void Swap(Range* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Range>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Range& from) { Range::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Range* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Range"; }

  explicit Range(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Range(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Range& from);
  Range(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Range&& from) noexcept
      : Range(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // float min = 1;
  void clear_min() ;
  float min() const;
  void set_min(float value);

  private:
  float _internal_min() const;
  void _internal_set_min(float value);

  public:
  // float max = 2;
  void clear_max() ;
  float max() const;
  void set_max(float value);

  private:
  float _internal_max() const;
  void _internal_set_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:Range)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Range& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float min_;
    float max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Range_class_data_;
// -------------------------------------------------------------------

class PointerReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplayEntry) */ {
 public:
  inline PointerReplayEntry() : PointerReplayEntry(nullptr) {}
  ~PointerReplayEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointerReplayEntry* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointerReplayEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplayEntry(::google::protobuf::internal::ConstantInitialized);

  inline PointerReplayEntry(const PointerReplayEntry& from) : PointerReplayEntry(nullptr, from) {}
  inline PointerReplayEntry(PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(nullptr, ::std::move(from)) {}
  inline PointerReplayEntry& operator=(const PointerReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplayEntry& operator=(PointerReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplayEntry& default_instance() {
    return *reinterpret_cast<const PointerReplayEntry*>(
        &_PointerReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PointerReplayEntry& a, PointerReplayEntry& b) { a.Swap(&b); }
  inline void Swap(PointerReplayEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplayEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplayEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplayEntry& from) { PointerReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointerReplayEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PointerReplayEntry"; }

  explicit PointerReplayEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointerReplayEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointerReplayEntry& from);
  PointerReplayEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointerReplayEntry&& from) noexcept
      : PointerReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kButtonFieldNumber = 1,
    kPressedFieldNumber = 2,
    kDelayMsFieldNumber = 3,
  };
  // uint32 button = 1;
  void clear_button() ;
  ::uint32_t button() const;
  void set_button(::uint32_t value);

  private:
  ::uint32_t _internal_button() const;
  void _internal_set_button(::uint32_t value);

  public:
  // bool pressed = 2;
  void clear_pressed() ;
  bool pressed() const;
  void set_pressed(bool value);

  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);

  public:
  // uint32 delay_ms = 3;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PointerReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointerReplayEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t button_;
    bool pressed_;
    ::uint32_t delay_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointerReplayEntry_class_data_;
// -------------------------------------------------------------------

class NoPayload final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:NoPayload) */ {
 public:
  inline NoPayload() : NoPayload(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NoPayload* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NoPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoPayload(::google::protobuf::internal::ConstantInitialized);

  inline NoPayload(const NoPayload& from) : NoPayload(nullptr, from) {}
  inline NoPayload(NoPayload&& from) noexcept
      : NoPayload(nullptr, ::std::move(from)) {}
  inline NoPayload& operator=(const NoPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoPayload& operator=(NoPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoPayload& default_instance() {
    return *reinterpret_cast<const NoPayload*>(
        &_NoPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NoPayload& a, NoPayload& b) { a.Swap(&b); }
  inline void Swap(NoPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoPayload* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoPayload* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NoPayload>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NoPayload& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "NoPayload"; }

  explicit NoPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NoPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NoPayload& from);
  NoPayload(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NoPayload&& from) noexcept
      : NoPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:NoPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NoPayload_class_data_;
// -------------------------------------------------------------------

class Move final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Move* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Move));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Move(::google::protobuf::internal::ConstantInitialized);

  inline Move(const Move& from) : Move(nullptr, from) {}
  inline Move(Move&& from) noexcept
      : Move(nullptr, ::std::move(from)) {}
  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *reinterpret_cast<const Move*>(
        &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Move& a, Move& b) { a.Swap(&b); }
  inline void Swap(Move* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Move& from) { Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Move* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Move"; }

  explicit Move(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Move(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Move& from);
  Move(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Move&& from) noexcept
      : Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXDeltaFieldNumber = 1,
    kYDeltaFieldNumber = 2,
    kZDeltaFieldNumber = 3,
    kUnitsPerSecondFieldNumber = 4,
  };
  // float xDelta = 1;
  void clear_xdelta() ;
  float xdelta() const;
  void set_xdelta(float value);

  private:
  float _internal_xdelta() const;
  void _internal_set_xdelta(float value);

  public:
  // float yDelta = 2;
  void clear_ydelta() ;
  float ydelta() const;
  void set_ydelta(float value);

  private:
  float _internal_ydelta() const;
  void _internal_set_ydelta(float value);

  public:
  // float zDelta = 3;
  void clear_zdelta() ;
  float zdelta() const;
  void set_zdelta(float value);

  private:
  float _internal_zdelta() const;
  void _internal_set_zdelta(float value);

  public:
  // float unitsPerSecond = 4;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Move& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float xdelta_;
    float ydelta_;
    float zdelta_;
    float unitspersecond_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Move_class_data_;
// -------------------------------------------------------------------

class ModelComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ModelComponent) */ {
 public:
  inline ModelComponent() : ModelComponent(nullptr) {}
  ~ModelComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelComponent(::google::protobuf::internal::ConstantInitialized);

  inline ModelComponent(const ModelComponent& from) : ModelComponent(nullptr, from) {}
  inline ModelComponent(ModelComponent&& from) noexcept
      : ModelComponent(nullptr, ::std::move(from)) {}
  inline ModelComponent& operator=(const ModelComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelComponent& operator=(ModelComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelComponent& default_instance() {
    return *reinterpret_cast<const ModelComponent*>(
        &_ModelComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ModelComponent& a, ModelComponent& b) { a.Swap(&b); }
  inline void Swap(ModelComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelComponent& from) { ModelComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ModelComponent"; }

  explicit ModelComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ModelComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ModelComponent& from);
  ModelComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ModelComponent&& from) noexcept
      : ModelComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelPathFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // string model_path = 2;
  void clear_model_path() ;
  const ::std::string& model_path() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_model_path(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_model_path();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_model_path();
  void set_allocated_model_path(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_model_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_model_path(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_model_path();

  public:
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ModelComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 33,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ModelComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr model_path_;
    ::int64_t entityid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ModelComponent_class_data_;
// -------------------------------------------------------------------

class ListEntities final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ListEntities) */ {
 public:
  inline ListEntities() : ListEntities(nullptr) {}
  ~ListEntities() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListEntities* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListEntities));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntities(::google::protobuf::internal::ConstantInitialized);

  inline ListEntities(const ListEntities& from) : ListEntities(nullptr, from) {}
  inline ListEntities(ListEntities&& from) noexcept
      : ListEntities(nullptr, ::std::move(from)) {}
  inline ListEntities& operator=(const ListEntities& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntities& operator=(ListEntities&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntities& default_instance() {
    return *reinterpret_cast<const ListEntities*>(
        &_ListEntities_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ListEntities& a, ListEntities& b) { a.Swap(&b); }
  inline void Swap(ListEntities* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntities* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntities* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListEntities>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListEntities& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListEntities& from) { ListEntities::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListEntities* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ListEntities"; }

  explicit ListEntities(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListEntities(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListEntities& from);
  ListEntities(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListEntities&& from) noexcept
      : ListEntities(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterTypeFieldNumber = 1,
  };
  // .ComponentType filter_type = 1;
  void clear_filter_type() ;
  ::ComponentType filter_type() const;
  void set_filter_type(::ComponentType value);

  private:
  ::ComponentType _internal_filter_type() const;
  void _internal_set_filter_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:ListEntities)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListEntities& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int filter_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ListEntities_class_data_;
// -------------------------------------------------------------------

class KeyReplayEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplayEntry) */ {
 public:
  inline KeyReplayEntry() : KeyReplayEntry(nullptr) {}
  ~KeyReplayEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyReplayEntry* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyReplayEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplayEntry(::google::protobuf::internal::ConstantInitialized);

  inline KeyReplayEntry(const KeyReplayEntry& from) : KeyReplayEntry(nullptr, from) {}
  inline KeyReplayEntry(KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(nullptr, ::std::move(from)) {}
  inline KeyReplayEntry& operator=(const KeyReplayEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplayEntry& operator=(KeyReplayEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplayEntry& default_instance() {
    return *reinterpret_cast<const KeyReplayEntry*>(
        &_KeyReplayEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(KeyReplayEntry& a, KeyReplayEntry& b) { a.Swap(&b); }
  inline void Swap(KeyReplayEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplayEntry* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplayEntry* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplayEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplayEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplayEntry& from) { KeyReplayEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyReplayEntry* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "KeyReplayEntry"; }

  explicit KeyReplayEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  KeyReplayEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const KeyReplayEntry& from);
  KeyReplayEntry(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, KeyReplayEntry&& from) noexcept
      : KeyReplayEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymFieldNumber = 1,
    kDelayMsFieldNumber = 2,
  };
  // string sym = 1;
  void clear_sym() ;
  const ::std::string& sym() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sym(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sym();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sym();
  void set_allocated_sym(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sym() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sym(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sym();

  public:
  // uint32 delay_ms = 2;
  void clear_delay_ms() ;
  ::uint32_t delay_ms() const;
  void set_delay_ms(::uint32_t value);

  private:
  ::uint32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:KeyReplayEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 26,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const KeyReplayEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sym_;
    ::uint32_t delay_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull KeyReplayEntry_class_data_;
// -------------------------------------------------------------------

class GetComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetComponent) */ {
 public:
  inline GetComponent() : GetComponent(nullptr) {}
  ~GetComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetComponent(::google::protobuf::internal::ConstantInitialized);

  inline GetComponent(const GetComponent& from) : GetComponent(nullptr, from) {}
  inline GetComponent(GetComponent&& from) noexcept
      : GetComponent(nullptr, ::std::move(from)) {}
  inline GetComponent& operator=(const GetComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetComponent& operator=(GetComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetComponent& default_instance() {
    return *reinterpret_cast<const GetComponent*>(
        &_GetComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetComponent& a, GetComponent& b) { a.Swap(&b); }
  inline void Swap(GetComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetComponent& from) { GetComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "GetComponent"; }

  explicit GetComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GetComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GetComponent& from);
  GetComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GetComponent&& from) noexcept
      : GetComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypeFieldNumber = 1,
  };
  // .ComponentType component_type = 1;
  void clear_component_type() ;
  ::ComponentType component_type() const;
  void set_component_type(::ComponentType value);

  private:
  ::ComponentType _internal_component_type() const;
  void _internal_set_component_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:GetComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GetComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int component_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetComponent_class_data_;
// -------------------------------------------------------------------

class EntityComponentInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EntityComponentInfo) */ {
 public:
  inline EntityComponentInfo() : EntityComponentInfo(nullptr) {}
  ~EntityComponentInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntityComponentInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntityComponentInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityComponentInfo(::google::protobuf::internal::ConstantInitialized);

  inline EntityComponentInfo(const EntityComponentInfo& from) : EntityComponentInfo(nullptr, from) {}
  inline EntityComponentInfo(EntityComponentInfo&& from) noexcept
      : EntityComponentInfo(nullptr, ::std::move(from)) {}
  inline EntityComponentInfo& operator=(const EntityComponentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityComponentInfo& operator=(EntityComponentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityComponentInfo& default_instance() {
    return *reinterpret_cast<const EntityComponentInfo*>(
        &_EntityComponentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(EntityComponentInfo& a, EntityComponentInfo& b) { a.Swap(&b); }
  inline void Swap(EntityComponentInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityComponentInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityComponentInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntityComponentInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityComponentInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntityComponentInfo& from) { EntityComponentInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntityComponentInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "EntityComponentInfo"; }

  explicit EntityComponentInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EntityComponentInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EntityComponentInfo& from);
  EntityComponentInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EntityComponentInfo&& from) noexcept
      : EntityComponentInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypesFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // repeated .ComponentType component_types = 2;
  int component_types_size() const;
  private:
  int _internal_component_types_size() const;

  public:
  void clear_component_types() ;
  public:
  ::ComponentType component_types(int index) const;
  void set_component_types(int index, ::ComponentType value);
  void add_component_types(::ComponentType value);
  const ::google::protobuf::RepeatedField<int>& component_types() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_component_types();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_component_types() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_component_types();

  public:
  // int64 entity_id = 1;
  void clear_entity_id() ;
  ::int64_t entity_id() const;
  void set_entity_id(::int64_t value);

  private:
  ::int64_t _internal_entity_id() const;
  void _internal_set_entity_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:EntityComponentInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EntityComponentInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> component_types_;
    ::google::protobuf::internal::CachedSize _component_types_cached_byte_size_;
    ::int64_t entity_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EntityComponentInfo_class_data_;
// -------------------------------------------------------------------

class DeleteEntity final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:DeleteEntity) */ {
 public:
  inline DeleteEntity() : DeleteEntity(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteEntity* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteEntity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteEntity(::google::protobuf::internal::ConstantInitialized);

  inline DeleteEntity(const DeleteEntity& from) : DeleteEntity(nullptr, from) {}
  inline DeleteEntity(DeleteEntity&& from) noexcept
      : DeleteEntity(nullptr, ::std::move(from)) {}
  inline DeleteEntity& operator=(const DeleteEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEntity& operator=(DeleteEntity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEntity& default_instance() {
    return *reinterpret_cast<const DeleteEntity*>(
        &_DeleteEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DeleteEntity& a, DeleteEntity& b) { a.Swap(&b); }
  inline void Swap(DeleteEntity* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEntity* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteEntity* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeleteEntity>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DeleteEntity"; }

  explicit DeleteEntity(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteEntity(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteEntity& from);
  DeleteEntity(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteEntity&& from) noexcept
      : DeleteEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:DeleteEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteEntity_class_data_;
// -------------------------------------------------------------------

class DeleteComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DeleteComponent) */ {
 public:
  inline DeleteComponent() : DeleteComponent(nullptr) {}
  ~DeleteComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteComponent(::google::protobuf::internal::ConstantInitialized);

  inline DeleteComponent(const DeleteComponent& from) : DeleteComponent(nullptr, from) {}
  inline DeleteComponent(DeleteComponent&& from) noexcept
      : DeleteComponent(nullptr, ::std::move(from)) {}
  inline DeleteComponent& operator=(const DeleteComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteComponent& operator=(DeleteComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteComponent& default_instance() {
    return *reinterpret_cast<const DeleteComponent*>(
        &_DeleteComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(DeleteComponent& a, DeleteComponent& b) { a.Swap(&b); }
  inline void Swap(DeleteComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteComponent& from) { DeleteComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DeleteComponent"; }

  explicit DeleteComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeleteComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeleteComponent& from);
  DeleteComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeleteComponent&& from) noexcept
      : DeleteComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentTypeFieldNumber = 1,
  };
  // .ComponentType component_type = 1;
  void clear_component_type() ;
  ::ComponentType component_type() const;
  void set_component_type(::ComponentType value);

  private:
  ::ComponentType _internal_component_type() const;
  void _internal_set_component_type(::ComponentType value);

  public:
  // @@protoc_insertion_point(class_scope:DeleteComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeleteComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int component_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeleteComponent_class_data_;
// -------------------------------------------------------------------

class CreateEntity final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:CreateEntity) */ {
 public:
  inline CreateEntity() : CreateEntity(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateEntity* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateEntity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateEntity(::google::protobuf::internal::ConstantInitialized);

  inline CreateEntity(const CreateEntity& from) : CreateEntity(nullptr, from) {}
  inline CreateEntity(CreateEntity&& from) noexcept
      : CreateEntity(nullptr, ::std::move(from)) {}
  inline CreateEntity& operator=(const CreateEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEntity& operator=(CreateEntity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEntity& default_instance() {
    return *reinterpret_cast<const CreateEntity*>(
        &_CreateEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CreateEntity& a, CreateEntity& b) { a.Swap(&b); }
  inline void Swap(CreateEntity* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEntity* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateEntity* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CreateEntity>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateEntity& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "CreateEntity"; }

  explicit CreateEntity(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CreateEntity(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CreateEntity& from);
  CreateEntity(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CreateEntity&& from) noexcept
      : CreateEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:CreateEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CreateEntity_class_data_;
// -------------------------------------------------------------------

class ConfirmAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ConfirmAction) */ {
 public:
  inline ConfirmAction() : ConfirmAction(nullptr) {}
  ~ConfirmAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConfirmAction* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConfirmAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConfirmAction(::google::protobuf::internal::ConstantInitialized);

  inline ConfirmAction(const ConfirmAction& from) : ConfirmAction(nullptr, from) {}
  inline ConfirmAction(ConfirmAction&& from) noexcept
      : ConfirmAction(nullptr, ::std::move(from)) {}
  inline ConfirmAction& operator=(const ConfirmAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmAction& operator=(ConfirmAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmAction& default_instance() {
    return *reinterpret_cast<const ConfirmAction*>(
        &_ConfirmAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ConfirmAction& a, ConfirmAction& b) { a.Swap(&b); }
  inline void Swap(ConfirmAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmAction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmAction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConfirmAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfirmAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConfirmAction& from) { ConfirmAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConfirmAction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ConfirmAction"; }

  explicit ConfirmAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConfirmAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConfirmAction& from);
  ConfirmAction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConfirmAction&& from) noexcept
      : ConfirmAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionIdFieldNumber = 1,
  };
  // int64 actionId = 1;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ConfirmAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConfirmAction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t actionid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConfirmAction_class_data_;
// -------------------------------------------------------------------

class PositionableComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PositionableComponent) */ {
 public:
  inline PositionableComponent() : PositionableComponent(nullptr) {}
  ~PositionableComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionableComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionableComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionableComponent(::google::protobuf::internal::ConstantInitialized);

  inline PositionableComponent(const PositionableComponent& from) : PositionableComponent(nullptr, from) {}
  inline PositionableComponent(PositionableComponent&& from) noexcept
      : PositionableComponent(nullptr, ::std::move(from)) {}
  inline PositionableComponent& operator=(const PositionableComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionableComponent& operator=(PositionableComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionableComponent& default_instance() {
    return *reinterpret_cast<const PositionableComponent*>(
        &_PositionableComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(PositionableComponent& a, PositionableComponent& b) { a.Swap(&b); }
  inline void Swap(PositionableComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionableComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionableComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionableComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionableComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionableComponent& from) { PositionableComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionableComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PositionableComponent"; }

  explicit PositionableComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionableComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionableComponent& from);
  PositionableComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionableComponent&& from) noexcept
      : PositionableComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kOriginFieldNumber = 5,
    kEntityIdFieldNumber = 1,
    kScaleFieldNumber = 4,
  };
  // .Vector position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::Vector& position() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_position();
  ::Vector* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::Vector& _internal_position() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .Vector rotation = 3;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::Vector& rotation() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_rotation();
  ::Vector* PROTOBUF_NONNULL mutable_rotation();
  void set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_rotation();

  private:
  const ::Vector& _internal_rotation() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_rotation();

  public:
  // .Vector origin = 5;
  bool has_origin() const;
  void clear_origin() ;
  const ::Vector& origin() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_origin();
  ::Vector* PROTOBUF_NONNULL mutable_origin();
  void set_allocated_origin(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_origin(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_origin();

  private:
  const ::Vector& _internal_origin() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_origin();

  public:
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // float scale = 4;
  void clear_scale() ;
  float scale() const;
  void set_scale(float value);

  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);

  public:
  // @@protoc_insertion_point(class_scope:PositionableComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionableComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* PROTOBUF_NULLABLE position_;
    ::Vector* PROTOBUF_NULLABLE rotation_;
    ::Vector* PROTOBUF_NULLABLE origin_;
    ::int64_t entityid_;
    float scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionableComponent_class_data_;
// -------------------------------------------------------------------

class PointerReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PointerReplay) */ {
 public:
  inline PointerReplay() : PointerReplay(nullptr) {}
  ~PointerReplay() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PointerReplay* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PointerReplay));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PointerReplay(::google::protobuf::internal::ConstantInitialized);

  inline PointerReplay(const PointerReplay& from) : PointerReplay(nullptr, from) {}
  inline PointerReplay(PointerReplay&& from) noexcept
      : PointerReplay(nullptr, ::std::move(from)) {}
  inline PointerReplay& operator=(const PointerReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointerReplay& operator=(PointerReplay&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointerReplay& default_instance() {
    return *reinterpret_cast<const PointerReplay*>(
        &_PointerReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PointerReplay& a, PointerReplay& b) { a.Swap(&b); }
  inline void Swap(PointerReplay* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointerReplay* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointerReplay* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PointerReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointerReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PointerReplay& from) { PointerReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PointerReplay* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PointerReplay"; }

  explicit PointerReplay(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PointerReplay(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PointerReplay& from);
  PointerReplay(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PointerReplay&& from) noexcept
      : PointerReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .PointerReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::PointerReplayEntry* PROTOBUF_NONNULL mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PROTOBUF_NONNULL mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PROTOBUF_NONNULL _internal_mutable_entries();
  public:
  const ::PointerReplayEntry& entries(int index) const;
  ::PointerReplayEntry* PROTOBUF_NONNULL add_entries();
  const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:PointerReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PointerReplay& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::PointerReplayEntry > entries_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PointerReplay_class_data_;
// -------------------------------------------------------------------

class PlayerMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMove) */ {
 public:
  inline PlayerMove() : PlayerMove(nullptr) {}
  ~PlayerMove() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerMove* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerMove));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMove(::google::protobuf::internal::ConstantInitialized);

  inline PlayerMove(const PlayerMove& from) : PlayerMove(nullptr, from) {}
  inline PlayerMove(PlayerMove&& from) noexcept
      : PlayerMove(nullptr, ::std::move(from)) {}
  inline PlayerMove& operator=(const PlayerMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMove& operator=(PlayerMove&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMove& default_instance() {
    return *reinterpret_cast<const PlayerMove*>(
        &_PlayerMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PlayerMove& a, PlayerMove& b) { a.Swap(&b); }
  inline void Swap(PlayerMove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMove* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMove* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMove& from) { PlayerMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerMove* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PlayerMove"; }

  explicit PlayerMove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerMove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerMove& from);
  PlayerMove(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerMove&& from) noexcept
      : PlayerMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
    kUnitsPerSecondFieldNumber = 3,
  };
  // .Vector position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::Vector& position() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_position();
  ::Vector* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::Vector& _internal_position() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .Vector rotation = 2;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::Vector& rotation() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_rotation();
  ::Vector* PROTOBUF_NONNULL mutable_rotation();
  void set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_rotation();

  private:
  const ::Vector& _internal_rotation() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_rotation();

  public:
  // float unitsPerSecond = 3;
  void clear_unitspersecond() ;
  float unitspersecond() const;
  void set_unitspersecond(float value);

  private:
  float _internal_unitspersecond() const;
  void _internal_set_unitspersecond(float value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerMove& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* PROTOBUF_NULLABLE position_;
    ::Vector* PROTOBUF_NULLABLE rotation_;
    float unitspersecond_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerMove_class_data_;
// -------------------------------------------------------------------

class KeyReplay final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:KeyReplay) */ {
 public:
  inline KeyReplay() : KeyReplay(nullptr) {}
  ~KeyReplay() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyReplay* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyReplay));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyReplay(::google::protobuf::internal::ConstantInitialized);

  inline KeyReplay(const KeyReplay& from) : KeyReplay(nullptr, from) {}
  inline KeyReplay(KeyReplay&& from) noexcept
      : KeyReplay(nullptr, ::std::move(from)) {}
  inline KeyReplay& operator=(const KeyReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyReplay& operator=(KeyReplay&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyReplay& default_instance() {
    return *reinterpret_cast<const KeyReplay*>(
        &_KeyReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(KeyReplay& a, KeyReplay& b) { a.Swap(&b); }
  inline void Swap(KeyReplay* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyReplay* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyReplay* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyReplay>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyReplay& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyReplay& from) { KeyReplay::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyReplay* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "KeyReplay"; }

  explicit KeyReplay(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  KeyReplay(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const KeyReplay& from);
  KeyReplay(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, KeyReplay&& from) noexcept
      : KeyReplay(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .KeyReplayEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::KeyReplayEntry* PROTOBUF_NONNULL mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* PROTOBUF_NONNULL mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* PROTOBUF_NONNULL _internal_mutable_entries();
  public:
  const ::KeyReplayEntry& entries(int index) const;
  ::KeyReplayEntry* PROTOBUF_NONNULL add_entries();
  const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:KeyReplay)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const KeyReplay& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::KeyReplayEntry > entries_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull KeyReplay_class_data_;
// -------------------------------------------------------------------

class EngineStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EngineStatus) */ {
 public:
  inline EngineStatus() : EngineStatus(nullptr) {}
  ~EngineStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EngineStatus* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EngineStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EngineStatus(::google::protobuf::internal::ConstantInitialized);

  inline EngineStatus(const EngineStatus& from) : EngineStatus(nullptr, from) {}
  inline EngineStatus(EngineStatus&& from) noexcept
      : EngineStatus(nullptr, ::std::move(from)) {}
  inline EngineStatus& operator=(const EngineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineStatus& operator=(EngineStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EngineStatus& default_instance() {
    return *reinterpret_cast<const EngineStatus*>(
        &_EngineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EngineStatus& a, EngineStatus& b) { a.Swap(&b); }
  inline void Swap(EngineStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EngineStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EngineStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EngineStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EngineStatus& from) { EngineStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EngineStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "EngineStatus"; }

  explicit EngineStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EngineStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EngineStatus& from);
  EngineStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EngineStatus&& from) noexcept
      : EngineStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCameraPositionFieldNumber = 4,
    kTotalEntitiesFieldNumber = 1,
    kWaylandAppsFieldNumber = 2,
    kWaylandFocusFieldNumber = 3,
  };
  // .Vector camera_position = 4;
  bool has_camera_position() const;
  void clear_camera_position() ;
  const ::Vector& camera_position() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_camera_position();
  ::Vector* PROTOBUF_NONNULL mutable_camera_position();
  void set_allocated_camera_position(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_camera_position(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_camera_position();

  private:
  const ::Vector& _internal_camera_position() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_camera_position();

  public:
  // uint32 total_entities = 1;
  void clear_total_entities() ;
  ::uint32_t total_entities() const;
  void set_total_entities(::uint32_t value);

  private:
  ::uint32_t _internal_total_entities() const;
  void _internal_set_total_entities(::uint32_t value);

  public:
  // uint32 wayland_apps = 2;
  void clear_wayland_apps() ;
  ::uint32_t wayland_apps() const;
  void set_wayland_apps(::uint32_t value);

  private:
  ::uint32_t _internal_wayland_apps() const;
  void _internal_set_wayland_apps(::uint32_t value);

  public:
  // bool wayland_focus = 3;
  void clear_wayland_focus() ;
  bool wayland_focus() const;
  void set_wayland_focus(bool value);

  private:
  bool _internal_wayland_focus() const;
  void _internal_set_wayland_focus(bool value);

  public:
  // @@protoc_insertion_point(class_scope:EngineStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EngineStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Vector* PROTOBUF_NULLABLE camera_position_;
    ::uint32_t total_entities_;
    ::uint32_t wayland_apps_;
    bool wayland_focus_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EngineStatus_class_data_;
// -------------------------------------------------------------------

class ClearVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ClearVoxels) */ {
 public:
  inline ClearVoxels() : ClearVoxels(nullptr) {}
  ~ClearVoxels() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClearVoxels* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClearVoxels));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearVoxels(::google::protobuf::internal::ConstantInitialized);

  inline ClearVoxels(const ClearVoxels& from) : ClearVoxels(nullptr, from) {}
  inline ClearVoxels(ClearVoxels&& from) noexcept
      : ClearVoxels(nullptr, ::std::move(from)) {}
  inline ClearVoxels& operator=(const ClearVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearVoxels& operator=(ClearVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearVoxels& default_instance() {
    return *reinterpret_cast<const ClearVoxels*>(
        &_ClearVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ClearVoxels& a, ClearVoxels& b) { a.Swap(&b); }
  inline void Swap(ClearVoxels* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearVoxels* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearVoxels* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClearVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearVoxels& from) { ClearVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClearVoxels* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ClearVoxels"; }

  explicit ClearVoxels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ClearVoxels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ClearVoxels& from);
  ClearVoxels(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ClearVoxels&& from) noexcept
      : ClearVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .Range x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::Range& x() const;
  [[nodiscard]] ::Range* PROTOBUF_NULLABLE release_x();
  ::Range* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::Range* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::Range* PROTOBUF_NULLABLE value);
  ::Range* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::Range& _internal_x() const;
  ::Range* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // .Range y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::Range& y() const;
  [[nodiscard]] ::Range* PROTOBUF_NULLABLE release_y();
  ::Range* PROTOBUF_NONNULL mutable_y();
  void set_allocated_y(::Range* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_y(::Range* PROTOBUF_NULLABLE value);
  ::Range* PROTOBUF_NULLABLE unsafe_arena_release_y();

  private:
  const ::Range& _internal_y() const;
  ::Range* PROTOBUF_NONNULL _internal_mutable_y();

  public:
  // .Range z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::Range& z() const;
  [[nodiscard]] ::Range* PROTOBUF_NULLABLE release_z();
  ::Range* PROTOBUF_NONNULL mutable_z();
  void set_allocated_z(::Range* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z(::Range* PROTOBUF_NULLABLE value);
  ::Range* PROTOBUF_NULLABLE unsafe_arena_release_z();

  private:
  const ::Range& _internal_z() const;
  ::Range* PROTOBUF_NONNULL _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:ClearVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ClearVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Range* PROTOBUF_NULLABLE x_;
    ::Range* PROTOBUF_NULLABLE y_;
    ::Range* PROTOBUF_NULLABLE z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ClearVoxels_class_data_;
// -------------------------------------------------------------------

class AddVoxels final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AddVoxels) */ {
 public:
  inline AddVoxels() : AddVoxels(nullptr) {}
  ~AddVoxels() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddVoxels* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddVoxels));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddVoxels(::google::protobuf::internal::ConstantInitialized);

  inline AddVoxels(const AddVoxels& from) : AddVoxels(nullptr, from) {}
  inline AddVoxels(AddVoxels&& from) noexcept
      : AddVoxels(nullptr, ::std::move(from)) {}
  inline AddVoxels& operator=(const AddVoxels& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddVoxels& operator=(AddVoxels&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddVoxels& default_instance() {
    return *reinterpret_cast<const AddVoxels*>(
        &_AddVoxels_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AddVoxels& a, AddVoxels& b) { a.Swap(&b); }
  inline void Swap(AddVoxels* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddVoxels* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddVoxels* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddVoxels>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddVoxels& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddVoxels& from) { AddVoxels::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddVoxels* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AddVoxels"; }

  explicit AddVoxels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AddVoxels(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AddVoxels& from);
  AddVoxels(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AddVoxels&& from) noexcept
      : AddVoxels(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVoxelsFieldNumber = 1,
    kColorFieldNumber = 4,
    kReplaceFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // repeated .VoxelCoord voxels = 1;
  int voxels_size() const;
  private:
  int _internal_voxels_size() const;

  public:
  void clear_voxels() ;
  ::VoxelCoord* PROTOBUF_NONNULL mutable_voxels(int index);
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* PROTOBUF_NONNULL mutable_voxels();

  private:
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& _internal_voxels() const;
  ::google::protobuf::RepeatedPtrField<::VoxelCoord>* PROTOBUF_NONNULL _internal_mutable_voxels();
  public:
  const ::VoxelCoord& voxels(int index) const;
  ::VoxelCoord* PROTOBUF_NONNULL add_voxels();
  const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& voxels() const;
  // .Vector color = 4;
  bool has_color() const;
  void clear_color() ;
  const ::Vector& color() const;
  [[nodiscard]] ::Vector* PROTOBUF_NULLABLE release_color();
  ::Vector* PROTOBUF_NONNULL mutable_color();
  void set_allocated_color(::Vector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_color(::Vector* PROTOBUF_NULLABLE value);
  ::Vector* PROTOBUF_NULLABLE unsafe_arena_release_color();

  private:
  const ::Vector& _internal_color() const;
  ::Vector* PROTOBUF_NONNULL _internal_mutable_color();

  public:
  // bool replace = 2;
  void clear_replace() ;
  bool replace() const;
  void set_replace(bool value);

  private:
  bool _internal_replace() const;
  void _internal_set_replace(bool value);

  public:
  // float size = 3;
  void clear_size() ;
  float size() const;
  void set_size(float value);

  private:
  float _internal_size() const;
  void _internal_set_size(float value);

  public:
  // @@protoc_insertion_point(class_scope:AddVoxels)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AddVoxels& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::VoxelCoord > voxels_;
    ::Vector* PROTOBUF_NULLABLE color_;
    bool replace_;
    float size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AddVoxels_class_data_;
// -------------------------------------------------------------------

class Component final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Component) */ {
 public:
  inline Component() : Component(nullptr) {}
  ~Component() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Component* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Component));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Component(::google::protobuf::internal::ConstantInitialized);

  inline Component(const Component& from) : Component(nullptr, from) {}
  inline Component(Component&& from) noexcept
      : Component(nullptr, ::std::move(from)) {}
  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }
  inline Component& operator=(Component&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Component& default_instance() {
    return *reinterpret_cast<const Component*>(
        &_Component_default_instance_);
  }
  enum ComponentTypeCase {
    kPositionable = 2,
    kModel = 3,
    COMPONENT_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(Component& a, Component& b) { a.Swap(&b); }
  inline void Swap(Component* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Component* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Component* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Component>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Component& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Component& from) { Component::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Component* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Component"; }

  explicit Component(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Component(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Component& from);
  Component(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Component&& from) noexcept
      : Component(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kPositionableFieldNumber = 2,
    kModelFieldNumber = 3,
  };
  // .ComponentType type = 1;
  void clear_type() ;
  ::ComponentType type() const;
  void set_type(::ComponentType value);

  private:
  ::ComponentType _internal_type() const;
  void _internal_set_type(::ComponentType value);

  public:
  // .PositionableComponent positionable = 2;
  bool has_positionable() const;
  private:
  bool _internal_has_positionable() const;

  public:
  void clear_positionable() ;
  const ::PositionableComponent& positionable() const;
  [[nodiscard]] ::PositionableComponent* PROTOBUF_NULLABLE release_positionable();
  ::PositionableComponent* PROTOBUF_NONNULL mutable_positionable();
  void set_allocated_positionable(::PositionableComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_positionable(::PositionableComponent* PROTOBUF_NULLABLE value);
  ::PositionableComponent* PROTOBUF_NULLABLE unsafe_arena_release_positionable();

  private:
  const ::PositionableComponent& _internal_positionable() const;
  ::PositionableComponent* PROTOBUF_NONNULL _internal_mutable_positionable();

  public:
  // .ModelComponent model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;

  public:
  void clear_model() ;
  const ::ModelComponent& model() const;
  [[nodiscard]] ::ModelComponent* PROTOBUF_NULLABLE release_model();
  ::ModelComponent* PROTOBUF_NONNULL mutable_model();
  void set_allocated_model(::ModelComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_model(::ModelComponent* PROTOBUF_NULLABLE value);
  ::ModelComponent* PROTOBUF_NULLABLE unsafe_arena_release_model();

  private:
  const ::ModelComponent& _internal_model() const;
  ::ModelComponent* PROTOBUF_NONNULL _internal_mutable_model();

  public:
  void clear_component_type();
  ComponentTypeCase component_type_case() const;
  // @@protoc_insertion_point(class_scope:Component)
 private:
  class _Internal;
  void set_has_positionable();
  void set_has_model();
  inline bool has_component_type() const;
  inline void clear_has_component_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Component& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    union ComponentTypeUnion {
      constexpr ComponentTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::PositionableComponent* PROTOBUF_NULLABLE positionable_;
      ::ModelComponent* PROTOBUF_NULLABLE model_;
    } component_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Component_class_data_;
// -------------------------------------------------------------------

class EditComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:EditComponent) */ {
 public:
  inline EditComponent() : EditComponent(nullptr) {}
  ~EditComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EditComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EditComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EditComponent(::google::protobuf::internal::ConstantInitialized);

  inline EditComponent(const EditComponent& from) : EditComponent(nullptr, from) {}
  inline EditComponent(EditComponent&& from) noexcept
      : EditComponent(nullptr, ::std::move(from)) {}
  inline EditComponent& operator=(const EditComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditComponent& operator=(EditComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditComponent& default_instance() {
    return *reinterpret_cast<const EditComponent*>(
        &_EditComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(EditComponent& a, EditComponent& b) { a.Swap(&b); }
  inline void Swap(EditComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EditComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EditComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EditComponent& from) { EditComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EditComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "EditComponent"; }

  explicit EditComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EditComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EditComponent& from);
  EditComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EditComponent&& from) noexcept
      : EditComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentFieldNumber = 1,
  };
  // .Component component = 1;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  [[nodiscard]] ::Component* PROTOBUF_NULLABLE release_component();
  ::Component* PROTOBUF_NONNULL mutable_component();
  void set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  ::Component* PROTOBUF_NULLABLE unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* PROTOBUF_NONNULL _internal_mutable_component();

  public:
  // @@protoc_insertion_point(class_scope:EditComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EditComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Component* PROTOBUF_NULLABLE component_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EditComponent_class_data_;
// -------------------------------------------------------------------

class ApiRequestResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequestResponse) */ {
 public:
  inline ApiRequestResponse() : ApiRequestResponse(nullptr) {}
  ~ApiRequestResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApiRequestResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApiRequestResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequestResponse(::google::protobuf::internal::ConstantInitialized);

  inline ApiRequestResponse(const ApiRequestResponse& from) : ApiRequestResponse(nullptr, from) {}
  inline ApiRequestResponse(ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(nullptr, ::std::move(from)) {}
  inline ApiRequestResponse& operator=(const ApiRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequestResponse& operator=(ApiRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequestResponse& default_instance() {
    return *reinterpret_cast<const ApiRequestResponse*>(
        &_ApiRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ApiRequestResponse& a, ApiRequestResponse& b) { a.Swap(&b); }
  inline void Swap(ApiRequestResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequestResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequestResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequestResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequestResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequestResponse& from) { ApiRequestResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApiRequestResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ApiRequestResponse"; }

  explicit ApiRequestResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ApiRequestResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ApiRequestResponse& from);
  ApiRequestResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ApiRequestResponse&& from) noexcept
      : ApiRequestResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdsFieldNumber = 5,
    kEntityComponentsFieldNumber = 7,
    kStatusFieldNumber = 4,
    kComponentFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kActionIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // repeated int64 entity_ids = 5;
  int entity_ids_size() const;
  private:
  int _internal_entity_ids_size() const;

  public:
  void clear_entity_ids() ;
  ::int64_t entity_ids(int index) const;
  void set_entity_ids(int index, ::int64_t value);
  void add_entity_ids(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& entity_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_entity_ids();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_entity_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_entity_ids();

  public:
  // repeated .EntityComponentInfo entity_components = 7;
  int entity_components_size() const;
  private:
  int _internal_entity_components_size() const;

  public:
  void clear_entity_components() ;
  ::EntityComponentInfo* PROTOBUF_NONNULL mutable_entity_components(int index);
  ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* PROTOBUF_NONNULL mutable_entity_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& _internal_entity_components() const;
  ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* PROTOBUF_NONNULL _internal_mutable_entity_components();
  public:
  const ::EntityComponentInfo& entity_components(int index) const;
  ::EntityComponentInfo* PROTOBUF_NONNULL add_entity_components();
  const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& entity_components() const;
  // .EngineStatus status = 4;
  bool has_status() const;
  void clear_status() ;
  const ::EngineStatus& status() const;
  [[nodiscard]] ::EngineStatus* PROTOBUF_NULLABLE release_status();
  ::EngineStatus* PROTOBUF_NONNULL mutable_status();
  void set_allocated_status(::EngineStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_status(::EngineStatus* PROTOBUF_NULLABLE value);
  ::EngineStatus* PROTOBUF_NULLABLE unsafe_arena_release_status();

  private:
  const ::EngineStatus& _internal_status() const;
  ::EngineStatus* PROTOBUF_NONNULL _internal_mutable_status();

  public:
  // .Component component = 6;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  [[nodiscard]] ::Component* PROTOBUF_NULLABLE release_component();
  ::Component* PROTOBUF_NONNULL mutable_component();
  void set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  ::Component* PROTOBUF_NULLABLE unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* PROTOBUF_NONNULL _internal_mutable_component();

  public:
  // int64 requestId = 1;
  void clear_requestid() ;
  ::int64_t requestid() const;
  void set_requestid(::int64_t value);

  private:
  ::int64_t _internal_requestid() const;
  void _internal_set_requestid(::int64_t value);

  public:
  // int64 actionId = 2;
  void clear_actionid() ;
  ::int64_t actionid() const;
  void set_actionid(::int64_t value);

  private:
  ::int64_t _internal_actionid() const;
  void _internal_set_actionid(::int64_t value);

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ApiRequestResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ApiRequestResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> entity_ids_;
    ::google::protobuf::internal::CachedSize _entity_ids_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::EntityComponentInfo > entity_components_;
    ::EngineStatus* PROTOBUF_NULLABLE status_;
    ::Component* PROTOBUF_NULLABLE component_;
    ::int64_t requestid_;
    ::int64_t actionid_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ApiRequestResponse_class_data_;
// -------------------------------------------------------------------

class AddComponent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AddComponent) */ {
 public:
  inline AddComponent() : AddComponent(nullptr) {}
  ~AddComponent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddComponent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddComponent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddComponent(::google::protobuf::internal::ConstantInitialized);

  inline AddComponent(const AddComponent& from) : AddComponent(nullptr, from) {}
  inline AddComponent(AddComponent&& from) noexcept
      : AddComponent(nullptr, ::std::move(from)) {}
  inline AddComponent& operator=(const AddComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddComponent& operator=(AddComponent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddComponent& default_instance() {
    return *reinterpret_cast<const AddComponent*>(
        &_AddComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AddComponent& a, AddComponent& b) { a.Swap(&b); }
  inline void Swap(AddComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddComponent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddComponent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddComponent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddComponent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddComponent& from) { AddComponent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddComponent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AddComponent"; }

  explicit AddComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AddComponent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AddComponent& from);
  AddComponent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AddComponent&& from) noexcept
      : AddComponent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComponentFieldNumber = 1,
  };
  // .Component component = 1;
  bool has_component() const;
  void clear_component() ;
  const ::Component& component() const;
  [[nodiscard]] ::Component* PROTOBUF_NULLABLE release_component();
  ::Component* PROTOBUF_NONNULL mutable_component();
  void set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_component(::Component* PROTOBUF_NULLABLE value);
  ::Component* PROTOBUF_NULLABLE unsafe_arena_release_component();

  private:
  const ::Component& _internal_component() const;
  ::Component* PROTOBUF_NONNULL _internal_mutable_component();

  public:
  // @@protoc_insertion_point(class_scope:AddComponent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AddComponent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Component* PROTOBUF_NULLABLE component_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AddComponent_class_data_;
// -------------------------------------------------------------------

class ApiRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApiRequest) */ {
 public:
  inline ApiRequest() : ApiRequest(nullptr) {}
  ~ApiRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApiRequest* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApiRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApiRequest(::google::protobuf::internal::ConstantInitialized);

  inline ApiRequest(const ApiRequest& from) : ApiRequest(nullptr, from) {}
  inline ApiRequest(ApiRequest&& from) noexcept
      : ApiRequest(nullptr, ::std::move(from)) {}
  inline ApiRequest& operator=(const ApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiRequest& operator=(ApiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiRequest& default_instance() {
    return *reinterpret_cast<const ApiRequest*>(
        &_ApiRequest_default_instance_);
  }
  enum PayloadCase {
    kMove = 3,
    kTurnKey = 4,
    kPlayerMove = 5,
    kNoPayload = 6,
    kAddVoxels = 7,
    kClearVoxels = 8,
    kConfirmAction = 9,
    kKeyReplay = 10,
    kPointerReplay = 11,
    kAddComponent = 12,
    kDeleteComponent = 13,
    kEditComponent = 14,
    kCreateEntity = 15,
    kDeleteEntity = 16,
    kListEntities = 17,
    kGetComponent = 18,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ApiRequest& a, ApiRequest& b) { a.Swap(&b); }
  inline void Swap(ApiRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiRequest* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiRequest* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApiRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApiRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApiRequest& from) { ApiRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApiRequest* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ApiRequest"; }

  explicit ApiRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ApiRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ApiRequest& from);
  ApiRequest(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ApiRequest&& from) noexcept
      : ApiRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kMoveFieldNumber = 3,
    kTurnKeyFieldNumber = 4,
    kPlayerMoveFieldNumber = 5,
    kNoPayloadFieldNumber = 6,
    kAddVoxelsFieldNumber = 7,
    kClearVoxelsFieldNumber = 8,
    kConfirmActionFieldNumber = 9,
    kKeyReplayFieldNumber = 10,
    kPointerReplayFieldNumber = 11,
    kAddComponentFieldNumber = 12,
    kDeleteComponentFieldNumber = 13,
    kEditComponentFieldNumber = 14,
    kCreateEntityFieldNumber = 15,
    kDeleteEntityFieldNumber = 16,
    kListEntitiesFieldNumber = 17,
    kGetComponentFieldNumber = 18,
  };
  // int64 entityId = 1;
  void clear_entityid() ;
  ::int64_t entityid() const;
  void set_entityid(::int64_t value);

  private:
  ::int64_t _internal_entityid() const;
  void _internal_set_entityid(::int64_t value);

  public:
  // .MessageType type = 2;
  void clear_type() ;
  ::MessageType type() const;
  void set_type(::MessageType value);

  private:
  ::MessageType _internal_type() const;
  void _internal_set_type(::MessageType value);

  public:
  // .Move move = 3;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::Move& move() const;
  [[nodiscard]] ::Move* PROTOBUF_NULLABLE release_move();
  ::Move* PROTOBUF_NONNULL mutable_move();
  void set_allocated_move(::Move* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_move(::Move* PROTOBUF_NULLABLE value);
  ::Move* PROTOBUF_NULLABLE unsafe_arena_release_move();

  private:
  const ::Move& _internal_move() const;
  ::Move* PROTOBUF_NONNULL _internal_mutable_move();

  public:
  // .TurnKey turnKey = 4;
  bool has_turnkey() const;
  private:
  bool _internal_has_turnkey() const;

  public:
  void clear_turnkey() ;
  const ::TurnKey& turnkey() const;
  [[nodiscard]] ::TurnKey* PROTOBUF_NULLABLE release_turnkey();
  ::TurnKey* PROTOBUF_NONNULL mutable_turnkey();
  void set_allocated_turnkey(::TurnKey* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_turnkey(::TurnKey* PROTOBUF_NULLABLE value);
  ::TurnKey* PROTOBUF_NULLABLE unsafe_arena_release_turnkey();

  private:
  const ::TurnKey& _internal_turnkey() const;
  ::TurnKey* PROTOBUF_NONNULL _internal_mutable_turnkey();

  public:
  // .PlayerMove playerMove = 5;
  bool has_playermove() const;
  private:
  bool _internal_has_playermove() const;

  public:
  void clear_playermove() ;
  const ::PlayerMove& playermove() const;
  [[nodiscard]] ::PlayerMove* PROTOBUF_NULLABLE release_playermove();
  ::PlayerMove* PROTOBUF_NONNULL mutable_playermove();
  void set_allocated_playermove(::PlayerMove* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_playermove(::PlayerMove* PROTOBUF_NULLABLE value);
  ::PlayerMove* PROTOBUF_NULLABLE unsafe_arena_release_playermove();

  private:
  const ::PlayerMove& _internal_playermove() const;
  ::PlayerMove* PROTOBUF_NONNULL _internal_mutable_playermove();

  public:
  // .NoPayload noPayload = 6;
  bool has_nopayload() const;
  private:
  bool _internal_has_nopayload() const;

  public:
  void clear_nopayload() ;
  const ::NoPayload& nopayload() const;
  [[nodiscard]] ::NoPayload* PROTOBUF_NULLABLE release_nopayload();
  ::NoPayload* PROTOBUF_NONNULL mutable_nopayload();
  void set_allocated_nopayload(::NoPayload* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nopayload(::NoPayload* PROTOBUF_NULLABLE value);
  ::NoPayload* PROTOBUF_NULLABLE unsafe_arena_release_nopayload();

  private:
  const ::NoPayload& _internal_nopayload() const;
  ::NoPayload* PROTOBUF_NONNULL _internal_mutable_nopayload();

  public:
  // .AddVoxels addVoxels = 7;
  bool has_addvoxels() const;
  private:
  bool _internal_has_addvoxels() const;

  public:
  void clear_addvoxels() ;
  const ::AddVoxels& addvoxels() const;
  [[nodiscard]] ::AddVoxels* PROTOBUF_NULLABLE release_addvoxels();
  ::AddVoxels* PROTOBUF_NONNULL mutable_addvoxels();
  void set_allocated_addvoxels(::AddVoxels* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_addvoxels(::AddVoxels* PROTOBUF_NULLABLE value);
  ::AddVoxels* PROTOBUF_NULLABLE unsafe_arena_release_addvoxels();

  private:
  const ::AddVoxels& _internal_addvoxels() const;
  ::AddVoxels* PROTOBUF_NONNULL _internal_mutable_addvoxels();

  public:
  // .ClearVoxels clearVoxels = 8;
  bool has_clearvoxels() const;
  private:
  bool _internal_has_clearvoxels() const;

  public:
  void clear_clearvoxels() ;
  const ::ClearVoxels& clearvoxels() const;
  [[nodiscard]] ::ClearVoxels* PROTOBUF_NULLABLE release_clearvoxels();
  ::ClearVoxels* PROTOBUF_NONNULL mutable_clearvoxels();
  void set_allocated_clearvoxels(::ClearVoxels* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_clearvoxels(::ClearVoxels* PROTOBUF_NULLABLE value);
  ::ClearVoxels* PROTOBUF_NULLABLE unsafe_arena_release_clearvoxels();

  private:
  const ::ClearVoxels& _internal_clearvoxels() const;
  ::ClearVoxels* PROTOBUF_NONNULL _internal_mutable_clearvoxels();

  public:
  // .ConfirmAction confirmAction = 9;
  bool has_confirmaction() const;
  private:
  bool _internal_has_confirmaction() const;

  public:
  void clear_confirmaction() ;
  const ::ConfirmAction& confirmaction() const;
  [[nodiscard]] ::ConfirmAction* PROTOBUF_NULLABLE release_confirmaction();
  ::ConfirmAction* PROTOBUF_NONNULL mutable_confirmaction();
  void set_allocated_confirmaction(::ConfirmAction* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confirmaction(::ConfirmAction* PROTOBUF_NULLABLE value);
  ::ConfirmAction* PROTOBUF_NULLABLE unsafe_arena_release_confirmaction();

  private:
  const ::ConfirmAction& _internal_confirmaction() const;
  ::ConfirmAction* PROTOBUF_NONNULL _internal_mutable_confirmaction();

  public:
  // .KeyReplay keyReplay = 10;
  bool has_keyreplay() const;
  private:
  bool _internal_has_keyreplay() const;

  public:
  void clear_keyreplay() ;
  const ::KeyReplay& keyreplay() const;
  [[nodiscard]] ::KeyReplay* PROTOBUF_NULLABLE release_keyreplay();
  ::KeyReplay* PROTOBUF_NONNULL mutable_keyreplay();
  void set_allocated_keyreplay(::KeyReplay* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_keyreplay(::KeyReplay* PROTOBUF_NULLABLE value);
  ::KeyReplay* PROTOBUF_NULLABLE unsafe_arena_release_keyreplay();

  private:
  const ::KeyReplay& _internal_keyreplay() const;
  ::KeyReplay* PROTOBUF_NONNULL _internal_mutable_keyreplay();

  public:
  // .PointerReplay pointerReplay = 11;
  bool has_pointerreplay() const;
  private:
  bool _internal_has_pointerreplay() const;

  public:
  void clear_pointerreplay() ;
  const ::PointerReplay& pointerreplay() const;
  [[nodiscard]] ::PointerReplay* PROTOBUF_NULLABLE release_pointerreplay();
  ::PointerReplay* PROTOBUF_NONNULL mutable_pointerreplay();
  void set_allocated_pointerreplay(::PointerReplay* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pointerreplay(::PointerReplay* PROTOBUF_NULLABLE value);
  ::PointerReplay* PROTOBUF_NULLABLE unsafe_arena_release_pointerreplay();

  private:
  const ::PointerReplay& _internal_pointerreplay() const;
  ::PointerReplay* PROTOBUF_NONNULL _internal_mutable_pointerreplay();

  public:
  // .AddComponent addComponent = 12;
  bool has_addcomponent() const;
  private:
  bool _internal_has_addcomponent() const;

  public:
  void clear_addcomponent() ;
  const ::AddComponent& addcomponent() const;
  [[nodiscard]] ::AddComponent* PROTOBUF_NULLABLE release_addcomponent();
  ::AddComponent* PROTOBUF_NONNULL mutable_addcomponent();
  void set_allocated_addcomponent(::AddComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_addcomponent(::AddComponent* PROTOBUF_NULLABLE value);
  ::AddComponent* PROTOBUF_NULLABLE unsafe_arena_release_addcomponent();

  private:
  const ::AddComponent& _internal_addcomponent() const;
  ::AddComponent* PROTOBUF_NONNULL _internal_mutable_addcomponent();

  public:
  // .DeleteComponent deleteComponent = 13;
  bool has_deletecomponent() const;
  private:
  bool _internal_has_deletecomponent() const;

  public:
  void clear_deletecomponent() ;
  const ::DeleteComponent& deletecomponent() const;
  [[nodiscard]] ::DeleteComponent* PROTOBUF_NULLABLE release_deletecomponent();
  ::DeleteComponent* PROTOBUF_NONNULL mutable_deletecomponent();
  void set_allocated_deletecomponent(::DeleteComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_deletecomponent(::DeleteComponent* PROTOBUF_NULLABLE value);
  ::DeleteComponent* PROTOBUF_NULLABLE unsafe_arena_release_deletecomponent();

  private:
  const ::DeleteComponent& _internal_deletecomponent() const;
  ::DeleteComponent* PROTOBUF_NONNULL _internal_mutable_deletecomponent();

  public:
  // .EditComponent editComponent = 14;
  bool has_editcomponent() const;
  private:
  bool _internal_has_editcomponent() const;

  public:
  void clear_editcomponent() ;
  const ::EditComponent& editcomponent() const;
  [[nodiscard]] ::EditComponent* PROTOBUF_NULLABLE release_editcomponent();
  ::EditComponent* PROTOBUF_NONNULL mutable_editcomponent();
  void set_allocated_editcomponent(::EditComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_editcomponent(::EditComponent* PROTOBUF_NULLABLE value);
  ::EditComponent* PROTOBUF_NULLABLE unsafe_arena_release_editcomponent();

  private:
  const ::EditComponent& _internal_editcomponent() const;
  ::EditComponent* PROTOBUF_NONNULL _internal_mutable_editcomponent();

  public:
  // .CreateEntity createEntity = 15;
  bool has_createentity() const;
  private:
  bool _internal_has_createentity() const;

  public:
  void clear_createentity() ;
  const ::CreateEntity& createentity() const;
  [[nodiscard]] ::CreateEntity* PROTOBUF_NULLABLE release_createentity();
  ::CreateEntity* PROTOBUF_NONNULL mutable_createentity();
  void set_allocated_createentity(::CreateEntity* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_createentity(::CreateEntity* PROTOBUF_NULLABLE value);
  ::CreateEntity* PROTOBUF_NULLABLE unsafe_arena_release_createentity();

  private:
  const ::CreateEntity& _internal_createentity() const;
  ::CreateEntity* PROTOBUF_NONNULL _internal_mutable_createentity();

  public:
  // .DeleteEntity deleteEntity = 16;
  bool has_deleteentity() const;
  private:
  bool _internal_has_deleteentity() const;

  public:
  void clear_deleteentity() ;
  const ::DeleteEntity& deleteentity() const;
  [[nodiscard]] ::DeleteEntity* PROTOBUF_NULLABLE release_deleteentity();
  ::DeleteEntity* PROTOBUF_NONNULL mutable_deleteentity();
  void set_allocated_deleteentity(::DeleteEntity* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_deleteentity(::DeleteEntity* PROTOBUF_NULLABLE value);
  ::DeleteEntity* PROTOBUF_NULLABLE unsafe_arena_release_deleteentity();

  private:
  const ::DeleteEntity& _internal_deleteentity() const;
  ::DeleteEntity* PROTOBUF_NONNULL _internal_mutable_deleteentity();

  public:
  // .ListEntities listEntities = 17;
  bool has_listentities() const;
  private:
  bool _internal_has_listentities() const;

  public:
  void clear_listentities() ;
  const ::ListEntities& listentities() const;
  [[nodiscard]] ::ListEntities* PROTOBUF_NULLABLE release_listentities();
  ::ListEntities* PROTOBUF_NONNULL mutable_listentities();
  void set_allocated_listentities(::ListEntities* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_listentities(::ListEntities* PROTOBUF_NULLABLE value);
  ::ListEntities* PROTOBUF_NULLABLE unsafe_arena_release_listentities();

  private:
  const ::ListEntities& _internal_listentities() const;
  ::ListEntities* PROTOBUF_NONNULL _internal_mutable_listentities();

  public:
  // .GetComponent getComponent = 18;
  bool has_getcomponent() const;
  private:
  bool _internal_has_getcomponent() const;

  public:
  void clear_getcomponent() ;
  const ::GetComponent& getcomponent() const;
  [[nodiscard]] ::GetComponent* PROTOBUF_NULLABLE release_getcomponent();
  ::GetComponent* PROTOBUF_NONNULL mutable_getcomponent();
  void set_allocated_getcomponent(::GetComponent* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_getcomponent(::GetComponent* PROTOBUF_NULLABLE value);
  ::GetComponent* PROTOBUF_NULLABLE unsafe_arena_release_getcomponent();

  private:
  const ::GetComponent& _internal_getcomponent() const;
  ::GetComponent* PROTOBUF_NONNULL _internal_mutable_getcomponent();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ApiRequest)
 private:
  class _Internal;
  void set_has_move();
  void set_has_turnkey();
  void set_has_playermove();
  void set_has_nopayload();
  void set_has_addvoxels();
  void set_has_clearvoxels();
  void set_has_confirmaction();
  void set_has_keyreplay();
  void set_has_pointerreplay();
  void set_has_addcomponent();
  void set_has_deletecomponent();
  void set_has_editcomponent();
  void set_has_createentity();
  void set_has_deleteentity();
  void set_has_listentities();
  void set_has_getcomponent();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 18,
                                   16, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ApiRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t entityid_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE move_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE turnkey_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE playermove_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE nopayload_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE addvoxels_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE clearvoxels_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE confirmaction_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE keyreplay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pointerreplay_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE addcomponent_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE deletecomponent_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE editcomponent_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE createentity_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE deleteentity_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE listentities_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE getcomponent_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fapi_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ApiRequest_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NoPayload

// -------------------------------------------------------------------

// Vector

// float x = 1;
inline void Vector::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:Vector.x)
  return _internal_x();
}
inline void Vector::set_x(float value) {
  _internal_set_x(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:Vector.x)
}
inline float Vector::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:Vector.y)
  return _internal_y();
}
inline void Vector::set_y(float value) {
  _internal_set_y(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:Vector.y)
}
inline float Vector::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:Vector.z)
  return _internal_z();
}
inline void Vector::set_z(float value) {
  _internal_set_z(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:Vector.z)
}
inline float Vector::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Range

// float min = 1;
inline void Range::clear_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Range::min() const {
  // @@protoc_insertion_point(field_get:Range.min)
  return _internal_min();
}
inline void Range::set_min(float value) {
  _internal_set_min(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:Range.min)
}
inline float Range::_internal_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_;
}
inline void Range::_internal_set_min(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_ = value;
}

// float max = 2;
inline void Range::clear_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float Range::max() const {
  // @@protoc_insertion_point(field_get:Range.max)
  return _internal_max();
}
inline void Range::set_max(float value) {
  _internal_set_max(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:Range.max)
}
inline float Range::_internal_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_;
}
inline void Range::_internal_set_max(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_ = value;
}

// -------------------------------------------------------------------

// PlayerMove

// .Vector position = 1;
inline bool PlayerMove::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerMove::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Vector& PlayerMove::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.position)
  return _internal_position();
}
inline void PlayerMove::unsafe_arena_set_allocated_position(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.position)
}
inline ::Vector* PROTOBUF_NULLABLE PlayerMove::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE PlayerMove::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL PlayerMove::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.position_;
}
inline ::Vector* PROTOBUF_NONNULL PlayerMove::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:PlayerMove.position)
  return _msg;
}
inline void PlayerMove::set_allocated_position(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.position)
}

// .Vector rotation = 2;
inline bool PlayerMove::has_rotation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PlayerMove::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::Vector& PlayerMove::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PlayerMove::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMove.rotation)
  return _internal_rotation();
}
inline void PlayerMove::unsafe_arena_set_allocated_rotation(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMove.rotation)
}
inline ::Vector* PROTOBUF_NULLABLE PlayerMove::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE PlayerMove::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PlayerMove.rotation)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL PlayerMove::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.rotation_;
}
inline ::Vector* PROTOBUF_NONNULL PlayerMove::mutable_rotation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PlayerMove.rotation)
  return _msg;
}
inline void PlayerMove::set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMove.rotation)
}

// float unitsPerSecond = 3;
inline void PlayerMove::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float PlayerMove::unitspersecond() const {
  // @@protoc_insertion_point(field_get:PlayerMove.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void PlayerMove::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:PlayerMove.unitsPerSecond)
}
inline float PlayerMove::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void PlayerMove::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// VoxelCoord

// float x = 1;
inline void VoxelCoord::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float VoxelCoord::x() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.x)
  return _internal_x();
}
inline void VoxelCoord::set_x(float value) {
  _internal_set_x(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:VoxelCoord.x)
}
inline float VoxelCoord::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void VoxelCoord::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void VoxelCoord::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float VoxelCoord::y() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.y)
  return _internal_y();
}
inline void VoxelCoord::set_y(float value) {
  _internal_set_y(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:VoxelCoord.y)
}
inline float VoxelCoord::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void VoxelCoord::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void VoxelCoord::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float VoxelCoord::z() const {
  // @@protoc_insertion_point(field_get:VoxelCoord.z)
  return _internal_z();
}
inline void VoxelCoord::set_z(float value) {
  _internal_set_z(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:VoxelCoord.z)
}
inline float VoxelCoord::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void VoxelCoord::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// AddVoxels

// repeated .VoxelCoord voxels = 1;
inline int AddVoxels::_internal_voxels_size() const {
  return _internal_voxels().size();
}
inline int AddVoxels::voxels_size() const {
  return _internal_voxels_size();
}
inline void AddVoxels::clear_voxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.voxels_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::VoxelCoord* PROTOBUF_NONNULL AddVoxels::mutable_voxels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AddVoxels.voxels)
  return _internal_mutable_voxels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>* PROTOBUF_NONNULL AddVoxels::mutable_voxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:AddVoxels.voxels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_voxels();
}
inline const ::VoxelCoord& AddVoxels::voxels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.voxels)
  return _internal_voxels().Get(index);
}
inline ::VoxelCoord* PROTOBUF_NONNULL AddVoxels::add_voxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::VoxelCoord* _add =
      _internal_mutable_voxels()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:AddVoxels.voxels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>& AddVoxels::voxels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AddVoxels.voxels)
  return _internal_voxels();
}
inline const ::google::protobuf::RepeatedPtrField<::VoxelCoord>&
AddVoxels::_internal_voxels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.voxels_;
}
inline ::google::protobuf::RepeatedPtrField<::VoxelCoord>* PROTOBUF_NONNULL
AddVoxels::_internal_mutable_voxels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.voxels_;
}

// bool replace = 2;
inline void AddVoxels::clear_replace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline bool AddVoxels::replace() const {
  // @@protoc_insertion_point(field_get:AddVoxels.replace)
  return _internal_replace();
}
inline void AddVoxels::set_replace(bool value) {
  _internal_set_replace(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:AddVoxels.replace)
}
inline bool AddVoxels::_internal_replace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replace_;
}
inline void AddVoxels::_internal_set_replace(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replace_ = value;
}

// float size = 3;
inline void AddVoxels::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline float AddVoxels::size() const {
  // @@protoc_insertion_point(field_get:AddVoxels.size)
  return _internal_size();
}
inline void AddVoxels::set_size(float value) {
  _internal_set_size(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:AddVoxels.size)
}
inline float AddVoxels::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void AddVoxels::_internal_set_size(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// .Vector color = 4;
inline bool AddVoxels::has_color() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void AddVoxels::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::Vector& AddVoxels::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& AddVoxels::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddVoxels.color)
  return _internal_color();
}
inline void AddVoxels::unsafe_arena_set_allocated_color(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AddVoxels.color)
}
inline ::Vector* PROTOBUF_NULLABLE AddVoxels::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* released = _impl_.color_;
  _impl_.color_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE AddVoxels::unsafe_arena_release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AddVoxels.color)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL AddVoxels::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.color_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.color_;
}
inline ::Vector* PROTOBUF_NONNULL AddVoxels::mutable_color()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:AddVoxels.color)
  return _msg;
}
inline void AddVoxels::set_allocated_color(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.color_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:AddVoxels.color)
}

// -------------------------------------------------------------------

// ClearVoxels

// .Range x = 1;
inline bool ClearVoxels::has_x() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Range& ClearVoxels::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.x)
  return _internal_x();
}
inline void ClearVoxels::unsafe_arena_set_allocated_x(
    ::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.x)
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Range* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.x)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Range* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.x_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.x_;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Range* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.x)
  return _msg;
}
inline void ClearVoxels::set_allocated_x(::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.x_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.x)
}

// .Range y = 2;
inline bool ClearVoxels::has_y() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::Range& ClearVoxels::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.y)
  return _internal_y();
}
inline void ClearVoxels::unsafe_arena_set_allocated_y(
    ::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.y)
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Range* released = _impl_.y_;
  _impl_.y_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.y)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Range* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.y_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.y_;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::mutable_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Range* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.y)
  return _msg;
}
inline void ClearVoxels::set_allocated_y(::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.y_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.y)
}

// .Range z = 3;
inline bool ClearVoxels::has_z() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline void ClearVoxels::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::Range& ClearVoxels::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Range* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::Range&>(::_Range_default_instance_);
}
inline const ::Range& ClearVoxels::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClearVoxels.z)
  return _internal_z();
}
inline void ClearVoxels::unsafe_arena_set_allocated_z(
    ::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::Range*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClearVoxels.z)
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Range* released = _impl_.z_;
  _impl_.z_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Range* PROTOBUF_NULLABLE ClearVoxels::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClearVoxels.z)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Range* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Range>(GetArena());
    _impl_.z_ = reinterpret_cast<::Range*>(p);
  }
  return _impl_.z_;
}
inline ::Range* PROTOBUF_NONNULL ClearVoxels::mutable_z()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Range* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:ClearVoxels.z)
  return _msg;
}
inline void ClearVoxels::set_allocated_z(::Range* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.z_ = reinterpret_cast<::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClearVoxels.z)
}

// -------------------------------------------------------------------

// ConfirmAction

// int64 actionId = 1;
inline void ConfirmAction::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t ConfirmAction::actionid() const {
  // @@protoc_insertion_point(field_get:ConfirmAction.actionId)
  return _internal_actionid();
}
inline void ConfirmAction::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:ConfirmAction.actionId)
}
inline ::int64_t ConfirmAction::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ConfirmAction::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// -------------------------------------------------------------------

// KeyReplayEntry

// string sym = 1;
inline void KeyReplayEntry::clear_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& KeyReplayEntry::sym() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.sym)
  return _internal_sym();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KeyReplayEntry::set_sym(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.sym_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KeyReplayEntry.sym)
}
inline ::std::string* PROTOBUF_NONNULL KeyReplayEntry::mutable_sym()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_sym();
  // @@protoc_insertion_point(field_mutable:KeyReplayEntry.sym)
  return _s;
}
inline const ::std::string& KeyReplayEntry::_internal_sym() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sym_.Get();
}
inline void KeyReplayEntry::_internal_set_sym(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sym_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KeyReplayEntry::_internal_mutable_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sym_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KeyReplayEntry::release_sym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:KeyReplayEntry.sym)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.sym_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sym_.Set("", GetArena());
  }
  return released;
}
inline void KeyReplayEntry::set_allocated_sym(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.sym_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sym_.IsDefault()) {
    _impl_.sym_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:KeyReplayEntry.sym)
}

// uint32 delay_ms = 2;
inline void KeyReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t KeyReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:KeyReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void KeyReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:KeyReplayEntry.delay_ms)
}
inline ::uint32_t KeyReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void KeyReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// KeyReplay

// repeated .KeyReplayEntry entries = 1;
inline int KeyReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int KeyReplay::entries_size() const {
  return _internal_entries_size();
}
inline void KeyReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::KeyReplayEntry* PROTOBUF_NONNULL KeyReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:KeyReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* PROTOBUF_NONNULL KeyReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:KeyReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::KeyReplayEntry& KeyReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KeyReplay.entries)
  return _internal_entries().Get(index);
}
inline ::KeyReplayEntry* PROTOBUF_NONNULL KeyReplay::add_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::KeyReplayEntry* _add =
      _internal_mutable_entries()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:KeyReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>& KeyReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:KeyReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>&
KeyReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::KeyReplayEntry>* PROTOBUF_NONNULL
KeyReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// PointerReplayEntry

// uint32 button = 1;
inline void PointerReplayEntry::clear_button() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::uint32_t PointerReplayEntry::button() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.button)
  return _internal_button();
}
inline void PointerReplayEntry::set_button(::uint32_t value) {
  _internal_set_button(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.button)
}
inline ::uint32_t PointerReplayEntry::_internal_button() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.button_;
}
inline void PointerReplayEntry::_internal_set_button(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_ = value;
}

// bool pressed = 2;
inline void PointerReplayEntry::clear_pressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline bool PointerReplayEntry::pressed() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.pressed)
  return _internal_pressed();
}
inline void PointerReplayEntry::set_pressed(bool value) {
  _internal_set_pressed(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.pressed)
}
inline bool PointerReplayEntry::_internal_pressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pressed_;
}
inline void PointerReplayEntry::_internal_set_pressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pressed_ = value;
}

// uint32 delay_ms = 3;
inline void PointerReplayEntry::clear_delay_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t PointerReplayEntry::delay_ms() const {
  // @@protoc_insertion_point(field_get:PointerReplayEntry.delay_ms)
  return _internal_delay_ms();
}
inline void PointerReplayEntry::set_delay_ms(::uint32_t value) {
  _internal_set_delay_ms(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:PointerReplayEntry.delay_ms)
}
inline ::uint32_t PointerReplayEntry::_internal_delay_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_ms_;
}
inline void PointerReplayEntry::_internal_set_delay_ms(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ms_ = value;
}

// -------------------------------------------------------------------

// PointerReplay

// repeated .PointerReplayEntry entries = 1;
inline int PointerReplay::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int PointerReplay::entries_size() const {
  return _internal_entries_size();
}
inline void PointerReplay::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::PointerReplayEntry* PROTOBUF_NONNULL PointerReplay::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:PointerReplay.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PROTOBUF_NONNULL PointerReplay::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:PointerReplay.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::PointerReplayEntry& PointerReplay::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PointerReplay.entries)
  return _internal_entries().Get(index);
}
inline ::PointerReplayEntry* PROTOBUF_NONNULL PointerReplay::add_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::PointerReplayEntry* _add =
      _internal_mutable_entries()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:PointerReplay.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>& PointerReplay::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:PointerReplay.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>&
PointerReplay::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::PointerReplayEntry>* PROTOBUF_NONNULL
PointerReplay::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// CreateEntity

// -------------------------------------------------------------------

// DeleteEntity

// -------------------------------------------------------------------

// ListEntities

// .ComponentType filter_type = 1;
inline void ListEntities::clear_filter_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ComponentType ListEntities::filter_type() const {
  // @@protoc_insertion_point(field_get:ListEntities.filter_type)
  return _internal_filter_type();
}
inline void ListEntities::set_filter_type(::ComponentType value) {
  _internal_set_filter_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:ListEntities.filter_type)
}
inline ::ComponentType ListEntities::_internal_filter_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.filter_type_);
}
inline void ListEntities::_internal_set_filter_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_type_ = value;
}

// -------------------------------------------------------------------

// GetComponent

// .ComponentType component_type = 1;
inline void GetComponent::clear_component_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ComponentType GetComponent::component_type() const {
  // @@protoc_insertion_point(field_get:GetComponent.component_type)
  return _internal_component_type();
}
inline void GetComponent::set_component_type(::ComponentType value) {
  _internal_set_component_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:GetComponent.component_type)
}
inline ::ComponentType GetComponent::_internal_component_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.component_type_);
}
inline void GetComponent::_internal_set_component_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = value;
}

// -------------------------------------------------------------------

// EngineStatus

// uint32 total_entities = 1;
inline void EngineStatus::clear_total_entities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::uint32_t EngineStatus::total_entities() const {
  // @@protoc_insertion_point(field_get:EngineStatus.total_entities)
  return _internal_total_entities();
}
inline void EngineStatus::set_total_entities(::uint32_t value) {
  _internal_set_total_entities(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:EngineStatus.total_entities)
}
inline ::uint32_t EngineStatus::_internal_total_entities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_entities_;
}
inline void EngineStatus::_internal_set_total_entities(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_entities_ = value;
}

// uint32 wayland_apps = 2;
inline void EngineStatus::clear_wayland_apps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::uint32_t EngineStatus::wayland_apps() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_apps)
  return _internal_wayland_apps();
}
inline void EngineStatus::set_wayland_apps(::uint32_t value) {
  _internal_set_wayland_apps(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_apps)
}
inline ::uint32_t EngineStatus::_internal_wayland_apps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_apps_;
}
inline void EngineStatus::_internal_set_wayland_apps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_apps_ = value;
}

// bool wayland_focus = 3;
inline void EngineStatus::clear_wayland_focus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool EngineStatus::wayland_focus() const {
  // @@protoc_insertion_point(field_get:EngineStatus.wayland_focus)
  return _internal_wayland_focus();
}
inline void EngineStatus::set_wayland_focus(bool value) {
  _internal_set_wayland_focus(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:EngineStatus.wayland_focus)
}
inline bool EngineStatus::_internal_wayland_focus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wayland_focus_;
}
inline void EngineStatus::_internal_set_wayland_focus(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wayland_focus_ = value;
}

// .Vector camera_position = 4;
inline bool EngineStatus::has_camera_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.camera_position_ != nullptr);
  return value;
}
inline void EngineStatus::clear_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ != nullptr) _impl_.camera_position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Vector& EngineStatus::_internal_camera_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.camera_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& EngineStatus::camera_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EngineStatus.camera_position)
  return _internal_camera_position();
}
inline void EngineStatus::unsafe_arena_set_allocated_camera_position(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_position_);
  }
  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EngineStatus.camera_position)
}
inline ::Vector* PROTOBUF_NULLABLE EngineStatus::release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* released = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE EngineStatus::unsafe_arena_release_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:EngineStatus.camera_position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* temp = _impl_.camera_position_;
  _impl_.camera_position_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL EngineStatus::_internal_mutable_camera_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.camera_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.camera_position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.camera_position_;
}
inline ::Vector* PROTOBUF_NONNULL EngineStatus::mutable_camera_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* _msg = _internal_mutable_camera_position();
  // @@protoc_insertion_point(field_mutable:EngineStatus.camera_position)
  return _msg;
}
inline void EngineStatus::set_allocated_camera_position(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.camera_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.camera_position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:EngineStatus.camera_position)
}

// -------------------------------------------------------------------

// Move

// float xDelta = 1;
inline void Move::clear_xdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline float Move::xdelta() const {
  // @@protoc_insertion_point(field_get:Move.xDelta)
  return _internal_xdelta();
}
inline void Move::set_xdelta(float value) {
  _internal_set_xdelta(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:Move.xDelta)
}
inline float Move::_internal_xdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xdelta_;
}
inline void Move::_internal_set_xdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xdelta_ = value;
}

// float yDelta = 2;
inline void Move::clear_ydelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline float Move::ydelta() const {
  // @@protoc_insertion_point(field_get:Move.yDelta)
  return _internal_ydelta();
}
inline void Move::set_ydelta(float value) {
  _internal_set_ydelta(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:Move.yDelta)
}
inline float Move::_internal_ydelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ydelta_;
}
inline void Move::_internal_set_ydelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ydelta_ = value;
}

// float zDelta = 3;
inline void Move::clear_zdelta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline float Move::zdelta() const {
  // @@protoc_insertion_point(field_get:Move.zDelta)
  return _internal_zdelta();
}
inline void Move::set_zdelta(float value) {
  _internal_set_zdelta(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:Move.zDelta)
}
inline float Move::_internal_zdelta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zdelta_;
}
inline void Move::_internal_set_zdelta(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zdelta_ = value;
}

// float unitsPerSecond = 4;
inline void Move::clear_unitspersecond() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline float Move::unitspersecond() const {
  // @@protoc_insertion_point(field_get:Move.unitsPerSecond)
  return _internal_unitspersecond();
}
inline void Move::set_unitspersecond(float value) {
  _internal_set_unitspersecond(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:Move.unitsPerSecond)
}
inline float Move::_internal_unitspersecond() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unitspersecond_;
}
inline void Move::_internal_set_unitspersecond(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unitspersecond_ = value;
}

// -------------------------------------------------------------------

// TurnKey

// bool on = 2;
inline void TurnKey::clear_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline bool TurnKey::on() const {
  // @@protoc_insertion_point(field_get:TurnKey.on)
  return _internal_on();
}
inline void TurnKey::set_on(bool value) {
  _internal_set_on(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:TurnKey.on)
}
inline bool TurnKey::_internal_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_;
}
inline void TurnKey::_internal_set_on(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_ = value;
}

// -------------------------------------------------------------------

// ApiRequest

// int64 entityId = 1;
inline void ApiRequest::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t ApiRequest::entityid() const {
  // @@protoc_insertion_point(field_get:ApiRequest.entityId)
  return _internal_entityid();
}
inline void ApiRequest::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:ApiRequest.entityId)
}
inline ::int64_t ApiRequest::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void ApiRequest::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// .MessageType type = 2;
inline void ApiRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::MessageType ApiRequest::type() const {
  // @@protoc_insertion_point(field_get:ApiRequest.type)
  return _internal_type();
}
inline void ApiRequest::set_type(::MessageType value) {
  _internal_set_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ApiRequest.type)
}
inline ::MessageType ApiRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MessageType>(_impl_.type_);
}
inline void ApiRequest::_internal_set_type(::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .Move move = 3;
inline bool ApiRequest::has_move() const {
  return payload_case() == kMove;
}
inline bool ApiRequest::_internal_has_move() const {
  return payload_case() == kMove;
}
inline void ApiRequest::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void ApiRequest::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.move_);
    }
    clear_has_payload();
  }
}
inline ::Move* PROTOBUF_NULLABLE ApiRequest::release_move() {
  // @@protoc_insertion_point(field_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::Move*>(_impl_.payload_.move_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Move& ApiRequest::_internal_move() const {
  return payload_case() == kMove ? static_cast<const ::Move&>(*reinterpret_cast<::Move*>(_impl_.payload_.move_))
                     : reinterpret_cast<const ::Move&>(::_Move_default_instance_);
}
inline const ::Move& ApiRequest::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.move)
  return _internal_move();
}
inline ::Move* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::Move*>(_impl_.payload_.move_);
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_move(
    ::Move* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move();
    _impl_.payload_.move_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.move)
}
inline ::Move* PROTOBUF_NONNULL ApiRequest::_internal_mutable_move() {
  if (payload_case() != kMove) {
    clear_payload();
    set_has_move();
    _impl_.payload_.move_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::Move>(GetArena()));
  }
  return reinterpret_cast<::Move*>(_impl_.payload_.move_);
}
inline ::Move* PROTOBUF_NONNULL ApiRequest::mutable_move()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:ApiRequest.move)
  return _msg;
}

// .TurnKey turnKey = 4;
inline bool ApiRequest::has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline bool ApiRequest::_internal_has_turnkey() const {
  return payload_case() == kTurnKey;
}
inline void ApiRequest::set_has_turnkey() {
  _impl_._oneof_case_[0] = kTurnKey;
}
inline void ApiRequest::clear_turnkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTurnKey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.turnkey_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.turnkey_);
    }
    clear_has_payload();
  }
}
inline ::TurnKey* PROTOBUF_NULLABLE ApiRequest::release_turnkey() {
  // @@protoc_insertion_point(field_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::TurnKey*>(_impl_.payload_.turnkey_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TurnKey& ApiRequest::_internal_turnkey() const {
  return payload_case() == kTurnKey ? static_cast<const ::TurnKey&>(*reinterpret_cast<::TurnKey*>(_impl_.payload_.turnkey_))
                     : reinterpret_cast<const ::TurnKey&>(::_TurnKey_default_instance_);
}
inline const ::TurnKey& ApiRequest::turnkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.turnKey)
  return _internal_turnkey();
}
inline ::TurnKey* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_turnkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.turnKey)
  if (payload_case() == kTurnKey) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::TurnKey*>(_impl_.payload_.turnkey_);
    _impl_.payload_.turnkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_turnkey(
    ::TurnKey* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_turnkey();
    _impl_.payload_.turnkey_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.turnKey)
}
inline ::TurnKey* PROTOBUF_NONNULL ApiRequest::_internal_mutable_turnkey() {
  if (payload_case() != kTurnKey) {
    clear_payload();
    set_has_turnkey();
    _impl_.payload_.turnkey_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::TurnKey>(GetArena()));
  }
  return reinterpret_cast<::TurnKey*>(_impl_.payload_.turnkey_);
}
inline ::TurnKey* PROTOBUF_NONNULL ApiRequest::mutable_turnkey()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::TurnKey* _msg = _internal_mutable_turnkey();
  // @@protoc_insertion_point(field_mutable:ApiRequest.turnKey)
  return _msg;
}

// .PlayerMove playerMove = 5;
inline bool ApiRequest::has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline bool ApiRequest::_internal_has_playermove() const {
  return payload_case() == kPlayerMove;
}
inline void ApiRequest::set_has_playermove() {
  _impl_._oneof_case_[0] = kPlayerMove;
}
inline void ApiRequest::clear_playermove() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPlayerMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.playermove_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.playermove_);
    }
    clear_has_payload();
  }
}
inline ::PlayerMove* PROTOBUF_NULLABLE ApiRequest::release_playermove() {
  // @@protoc_insertion_point(field_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::PlayerMove*>(_impl_.payload_.playermove_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlayerMove& ApiRequest::_internal_playermove() const {
  return payload_case() == kPlayerMove ? static_cast<const ::PlayerMove&>(*reinterpret_cast<::PlayerMove*>(_impl_.payload_.playermove_))
                     : reinterpret_cast<const ::PlayerMove&>(::_PlayerMove_default_instance_);
}
inline const ::PlayerMove& ApiRequest::playermove() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.playerMove)
  return _internal_playermove();
}
inline ::PlayerMove* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_playermove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.playerMove)
  if (payload_case() == kPlayerMove) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::PlayerMove*>(_impl_.payload_.playermove_);
    _impl_.payload_.playermove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_playermove(
    ::PlayerMove* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_playermove();
    _impl_.payload_.playermove_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.playerMove)
}
inline ::PlayerMove* PROTOBUF_NONNULL ApiRequest::_internal_mutable_playermove() {
  if (payload_case() != kPlayerMove) {
    clear_payload();
    set_has_playermove();
    _impl_.payload_.playermove_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::PlayerMove>(GetArena()));
  }
  return reinterpret_cast<::PlayerMove*>(_impl_.payload_.playermove_);
}
inline ::PlayerMove* PROTOBUF_NONNULL ApiRequest::mutable_playermove()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlayerMove* _msg = _internal_mutable_playermove();
  // @@protoc_insertion_point(field_mutable:ApiRequest.playerMove)
  return _msg;
}

// .NoPayload noPayload = 6;
inline bool ApiRequest::has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline bool ApiRequest::_internal_has_nopayload() const {
  return payload_case() == kNoPayload;
}
inline void ApiRequest::set_has_nopayload() {
  _impl_._oneof_case_[0] = kNoPayload;
}
inline void ApiRequest::clear_nopayload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kNoPayload) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.nopayload_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.nopayload_);
    }
    clear_has_payload();
  }
}
inline ::NoPayload* PROTOBUF_NULLABLE ApiRequest::release_nopayload() {
  // @@protoc_insertion_point(field_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::NoPayload*>(_impl_.payload_.nopayload_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::NoPayload& ApiRequest::_internal_nopayload() const {
  return payload_case() == kNoPayload ? static_cast<const ::NoPayload&>(*reinterpret_cast<::NoPayload*>(_impl_.payload_.nopayload_))
                     : reinterpret_cast<const ::NoPayload&>(::_NoPayload_default_instance_);
}
inline const ::NoPayload& ApiRequest::nopayload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.noPayload)
  return _internal_nopayload();
}
inline ::NoPayload* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_nopayload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.noPayload)
  if (payload_case() == kNoPayload) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::NoPayload*>(_impl_.payload_.nopayload_);
    _impl_.payload_.nopayload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_nopayload(
    ::NoPayload* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_nopayload();
    _impl_.payload_.nopayload_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.noPayload)
}
inline ::NoPayload* PROTOBUF_NONNULL ApiRequest::_internal_mutable_nopayload() {
  if (payload_case() != kNoPayload) {
    clear_payload();
    set_has_nopayload();
    _impl_.payload_.nopayload_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::NoPayload>(GetArena()));
  }
  return reinterpret_cast<::NoPayload*>(_impl_.payload_.nopayload_);
}
inline ::NoPayload* PROTOBUF_NONNULL ApiRequest::mutable_nopayload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::NoPayload* _msg = _internal_mutable_nopayload();
  // @@protoc_insertion_point(field_mutable:ApiRequest.noPayload)
  return _msg;
}

// .AddVoxels addVoxels = 7;
inline bool ApiRequest::has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline bool ApiRequest::_internal_has_addvoxels() const {
  return payload_case() == kAddVoxels;
}
inline void ApiRequest::set_has_addvoxels() {
  _impl_._oneof_case_[0] = kAddVoxels;
}
inline void ApiRequest::clear_addvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.addvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.addvoxels_);
    }
    clear_has_payload();
  }
}
inline ::AddVoxels* PROTOBUF_NULLABLE ApiRequest::release_addvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::AddVoxels*>(_impl_.payload_.addvoxels_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AddVoxels& ApiRequest::_internal_addvoxels() const {
  return payload_case() == kAddVoxels ? static_cast<const ::AddVoxels&>(*reinterpret_cast<::AddVoxels*>(_impl_.payload_.addvoxels_))
                     : reinterpret_cast<const ::AddVoxels&>(::_AddVoxels_default_instance_);
}
inline const ::AddVoxels& ApiRequest::addvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.addVoxels)
  return _internal_addvoxels();
}
inline ::AddVoxels* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_addvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.addVoxels)
  if (payload_case() == kAddVoxels) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::AddVoxels*>(_impl_.payload_.addvoxels_);
    _impl_.payload_.addvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_addvoxels(
    ::AddVoxels* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.addVoxels)
}
inline ::AddVoxels* PROTOBUF_NONNULL ApiRequest::_internal_mutable_addvoxels() {
  if (payload_case() != kAddVoxels) {
    clear_payload();
    set_has_addvoxels();
    _impl_.payload_.addvoxels_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::AddVoxels>(GetArena()));
  }
  return reinterpret_cast<::AddVoxels*>(_impl_.payload_.addvoxels_);
}
inline ::AddVoxels* PROTOBUF_NONNULL ApiRequest::mutable_addvoxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AddVoxels* _msg = _internal_mutable_addvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.addVoxels)
  return _msg;
}

// .ClearVoxels clearVoxels = 8;
inline bool ApiRequest::has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline bool ApiRequest::_internal_has_clearvoxels() const {
  return payload_case() == kClearVoxels;
}
inline void ApiRequest::set_has_clearvoxels() {
  _impl_._oneof_case_[0] = kClearVoxels;
}
inline void ApiRequest::clear_clearvoxels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kClearVoxels) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.clearvoxels_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.clearvoxels_);
    }
    clear_has_payload();
  }
}
inline ::ClearVoxels* PROTOBUF_NULLABLE ApiRequest::release_clearvoxels() {
  // @@protoc_insertion_point(field_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ClearVoxels*>(_impl_.payload_.clearvoxels_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClearVoxels& ApiRequest::_internal_clearvoxels() const {
  return payload_case() == kClearVoxels ? static_cast<const ::ClearVoxels&>(*reinterpret_cast<::ClearVoxels*>(_impl_.payload_.clearvoxels_))
                     : reinterpret_cast<const ::ClearVoxels&>(::_ClearVoxels_default_instance_);
}
inline const ::ClearVoxels& ApiRequest::clearvoxels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.clearVoxels)
  return _internal_clearvoxels();
}
inline ::ClearVoxels* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_clearvoxels() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.clearVoxels)
  if (payload_case() == kClearVoxels) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ClearVoxels*>(_impl_.payload_.clearvoxels_);
    _impl_.payload_.clearvoxels_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_clearvoxels(
    ::ClearVoxels* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.clearVoxels)
}
inline ::ClearVoxels* PROTOBUF_NONNULL ApiRequest::_internal_mutable_clearvoxels() {
  if (payload_case() != kClearVoxels) {
    clear_payload();
    set_has_clearvoxels();
    _impl_.payload_.clearvoxels_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::ClearVoxels>(GetArena()));
  }
  return reinterpret_cast<::ClearVoxels*>(_impl_.payload_.clearvoxels_);
}
inline ::ClearVoxels* PROTOBUF_NONNULL ApiRequest::mutable_clearvoxels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ClearVoxels* _msg = _internal_mutable_clearvoxels();
  // @@protoc_insertion_point(field_mutable:ApiRequest.clearVoxels)
  return _msg;
}

// .ConfirmAction confirmAction = 9;
inline bool ApiRequest::has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline bool ApiRequest::_internal_has_confirmaction() const {
  return payload_case() == kConfirmAction;
}
inline void ApiRequest::set_has_confirmaction() {
  _impl_._oneof_case_[0] = kConfirmAction;
}
inline void ApiRequest::clear_confirmaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConfirmAction) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.confirmaction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.confirmaction_);
    }
    clear_has_payload();
  }
}
inline ::ConfirmAction* PROTOBUF_NULLABLE ApiRequest::release_confirmaction() {
  // @@protoc_insertion_point(field_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ConfirmAction*>(_impl_.payload_.confirmaction_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ConfirmAction& ApiRequest::_internal_confirmaction() const {
  return payload_case() == kConfirmAction ? static_cast<const ::ConfirmAction&>(*reinterpret_cast<::ConfirmAction*>(_impl_.payload_.confirmaction_))
                     : reinterpret_cast<const ::ConfirmAction&>(::_ConfirmAction_default_instance_);
}
inline const ::ConfirmAction& ApiRequest::confirmaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.confirmAction)
  return _internal_confirmaction();
}
inline ::ConfirmAction* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_confirmaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.confirmAction)
  if (payload_case() == kConfirmAction) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ConfirmAction*>(_impl_.payload_.confirmaction_);
    _impl_.payload_.confirmaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_confirmaction(
    ::ConfirmAction* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.confirmAction)
}
inline ::ConfirmAction* PROTOBUF_NONNULL ApiRequest::_internal_mutable_confirmaction() {
  if (payload_case() != kConfirmAction) {
    clear_payload();
    set_has_confirmaction();
    _impl_.payload_.confirmaction_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::ConfirmAction>(GetArena()));
  }
  return reinterpret_cast<::ConfirmAction*>(_impl_.payload_.confirmaction_);
}
inline ::ConfirmAction* PROTOBUF_NONNULL ApiRequest::mutable_confirmaction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ConfirmAction* _msg = _internal_mutable_confirmaction();
  // @@protoc_insertion_point(field_mutable:ApiRequest.confirmAction)
  return _msg;
}

// .KeyReplay keyReplay = 10;
inline bool ApiRequest::has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline bool ApiRequest::_internal_has_keyreplay() const {
  return payload_case() == kKeyReplay;
}
inline void ApiRequest::set_has_keyreplay() {
  _impl_._oneof_case_[0] = kKeyReplay;
}
inline void ApiRequest::clear_keyreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kKeyReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.keyreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.keyreplay_);
    }
    clear_has_payload();
  }
}
inline ::KeyReplay* PROTOBUF_NULLABLE ApiRequest::release_keyreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::KeyReplay*>(_impl_.payload_.keyreplay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KeyReplay& ApiRequest::_internal_keyreplay() const {
  return payload_case() == kKeyReplay ? static_cast<const ::KeyReplay&>(*reinterpret_cast<::KeyReplay*>(_impl_.payload_.keyreplay_))
                     : reinterpret_cast<const ::KeyReplay&>(::_KeyReplay_default_instance_);
}
inline const ::KeyReplay& ApiRequest::keyreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.keyReplay)
  return _internal_keyreplay();
}
inline ::KeyReplay* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_keyreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.keyReplay)
  if (payload_case() == kKeyReplay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::KeyReplay*>(_impl_.payload_.keyreplay_);
    _impl_.payload_.keyreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_keyreplay(
    ::KeyReplay* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.keyReplay)
}
inline ::KeyReplay* PROTOBUF_NONNULL ApiRequest::_internal_mutable_keyreplay() {
  if (payload_case() != kKeyReplay) {
    clear_payload();
    set_has_keyreplay();
    _impl_.payload_.keyreplay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::KeyReplay>(GetArena()));
  }
  return reinterpret_cast<::KeyReplay*>(_impl_.payload_.keyreplay_);
}
inline ::KeyReplay* PROTOBUF_NONNULL ApiRequest::mutable_keyreplay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::KeyReplay* _msg = _internal_mutable_keyreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.keyReplay)
  return _msg;
}

// .PointerReplay pointerReplay = 11;
inline bool ApiRequest::has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline bool ApiRequest::_internal_has_pointerreplay() const {
  return payload_case() == kPointerReplay;
}
inline void ApiRequest::set_has_pointerreplay() {
  _impl_._oneof_case_[0] = kPointerReplay;
}
inline void ApiRequest::clear_pointerreplay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPointerReplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.pointerreplay_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.pointerreplay_);
    }
    clear_has_payload();
  }
}
inline ::PointerReplay* PROTOBUF_NULLABLE ApiRequest::release_pointerreplay() {
  // @@protoc_insertion_point(field_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::PointerReplay*>(_impl_.payload_.pointerreplay_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PointerReplay& ApiRequest::_internal_pointerreplay() const {
  return payload_case() == kPointerReplay ? static_cast<const ::PointerReplay&>(*reinterpret_cast<::PointerReplay*>(_impl_.payload_.pointerreplay_))
                     : reinterpret_cast<const ::PointerReplay&>(::_PointerReplay_default_instance_);
}
inline const ::PointerReplay& ApiRequest::pointerreplay() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.pointerReplay)
  return _internal_pointerreplay();
}
inline ::PointerReplay* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_pointerreplay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.pointerReplay)
  if (payload_case() == kPointerReplay) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::PointerReplay*>(_impl_.payload_.pointerreplay_);
    _impl_.payload_.pointerreplay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_pointerreplay(
    ::PointerReplay* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.pointerReplay)
}
inline ::PointerReplay* PROTOBUF_NONNULL ApiRequest::_internal_mutable_pointerreplay() {
  if (payload_case() != kPointerReplay) {
    clear_payload();
    set_has_pointerreplay();
    _impl_.payload_.pointerreplay_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::PointerReplay>(GetArena()));
  }
  return reinterpret_cast<::PointerReplay*>(_impl_.payload_.pointerreplay_);
}
inline ::PointerReplay* PROTOBUF_NONNULL ApiRequest::mutable_pointerreplay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PointerReplay* _msg = _internal_mutable_pointerreplay();
  // @@protoc_insertion_point(field_mutable:ApiRequest.pointerReplay)
  return _msg;
}

// .AddComponent addComponent = 12;
inline bool ApiRequest::has_addcomponent() const {
  return payload_case() == kAddComponent;
}
inline bool ApiRequest::_internal_has_addcomponent() const {
  return payload_case() == kAddComponent;
}
inline void ApiRequest::set_has_addcomponent() {
  _impl_._oneof_case_[0] = kAddComponent;
}
inline void ApiRequest::clear_addcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.addcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.addcomponent_);
    }
    clear_has_payload();
  }
}
inline ::AddComponent* PROTOBUF_NULLABLE ApiRequest::release_addcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.addComponent)
  if (payload_case() == kAddComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::AddComponent*>(_impl_.payload_.addcomponent_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.addcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AddComponent& ApiRequest::_internal_addcomponent() const {
  return payload_case() == kAddComponent ? static_cast<const ::AddComponent&>(*reinterpret_cast<::AddComponent*>(_impl_.payload_.addcomponent_))
                     : reinterpret_cast<const ::AddComponent&>(::_AddComponent_default_instance_);
}
inline const ::AddComponent& ApiRequest::addcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.addComponent)
  return _internal_addcomponent();
}
inline ::AddComponent* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_addcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.addComponent)
  if (payload_case() == kAddComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::AddComponent*>(_impl_.payload_.addcomponent_);
    _impl_.payload_.addcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_addcomponent(
    ::AddComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_addcomponent();
    _impl_.payload_.addcomponent_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.addComponent)
}
inline ::AddComponent* PROTOBUF_NONNULL ApiRequest::_internal_mutable_addcomponent() {
  if (payload_case() != kAddComponent) {
    clear_payload();
    set_has_addcomponent();
    _impl_.payload_.addcomponent_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::AddComponent>(GetArena()));
  }
  return reinterpret_cast<::AddComponent*>(_impl_.payload_.addcomponent_);
}
inline ::AddComponent* PROTOBUF_NONNULL ApiRequest::mutable_addcomponent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::AddComponent* _msg = _internal_mutable_addcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.addComponent)
  return _msg;
}

// .DeleteComponent deleteComponent = 13;
inline bool ApiRequest::has_deletecomponent() const {
  return payload_case() == kDeleteComponent;
}
inline bool ApiRequest::_internal_has_deletecomponent() const {
  return payload_case() == kDeleteComponent;
}
inline void ApiRequest::set_has_deletecomponent() {
  _impl_._oneof_case_[0] = kDeleteComponent;
}
inline void ApiRequest::clear_deletecomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.deletecomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.deletecomponent_);
    }
    clear_has_payload();
  }
}
inline ::DeleteComponent* PROTOBUF_NULLABLE ApiRequest::release_deletecomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.deleteComponent)
  if (payload_case() == kDeleteComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::DeleteComponent*>(_impl_.payload_.deletecomponent_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deletecomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeleteComponent& ApiRequest::_internal_deletecomponent() const {
  return payload_case() == kDeleteComponent ? static_cast<const ::DeleteComponent&>(*reinterpret_cast<::DeleteComponent*>(_impl_.payload_.deletecomponent_))
                     : reinterpret_cast<const ::DeleteComponent&>(::_DeleteComponent_default_instance_);
}
inline const ::DeleteComponent& ApiRequest::deletecomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.deleteComponent)
  return _internal_deletecomponent();
}
inline ::DeleteComponent* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_deletecomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.deleteComponent)
  if (payload_case() == kDeleteComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::DeleteComponent*>(_impl_.payload_.deletecomponent_);
    _impl_.payload_.deletecomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_deletecomponent(
    ::DeleteComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_deletecomponent();
    _impl_.payload_.deletecomponent_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.deleteComponent)
}
inline ::DeleteComponent* PROTOBUF_NONNULL ApiRequest::_internal_mutable_deletecomponent() {
  if (payload_case() != kDeleteComponent) {
    clear_payload();
    set_has_deletecomponent();
    _impl_.payload_.deletecomponent_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::DeleteComponent>(GetArena()));
  }
  return reinterpret_cast<::DeleteComponent*>(_impl_.payload_.deletecomponent_);
}
inline ::DeleteComponent* PROTOBUF_NONNULL ApiRequest::mutable_deletecomponent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DeleteComponent* _msg = _internal_mutable_deletecomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.deleteComponent)
  return _msg;
}

// .EditComponent editComponent = 14;
inline bool ApiRequest::has_editcomponent() const {
  return payload_case() == kEditComponent;
}
inline bool ApiRequest::_internal_has_editcomponent() const {
  return payload_case() == kEditComponent;
}
inline void ApiRequest::set_has_editcomponent() {
  _impl_._oneof_case_[0] = kEditComponent;
}
inline void ApiRequest::clear_editcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kEditComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.editcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.editcomponent_);
    }
    clear_has_payload();
  }
}
inline ::EditComponent* PROTOBUF_NULLABLE ApiRequest::release_editcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.editComponent)
  if (payload_case() == kEditComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::EditComponent*>(_impl_.payload_.editcomponent_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.editcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::EditComponent& ApiRequest::_internal_editcomponent() const {
  return payload_case() == kEditComponent ? static_cast<const ::EditComponent&>(*reinterpret_cast<::EditComponent*>(_impl_.payload_.editcomponent_))
                     : reinterpret_cast<const ::EditComponent&>(::_EditComponent_default_instance_);
}
inline const ::EditComponent& ApiRequest::editcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.editComponent)
  return _internal_editcomponent();
}
inline ::EditComponent* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_editcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.editComponent)
  if (payload_case() == kEditComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::EditComponent*>(_impl_.payload_.editcomponent_);
    _impl_.payload_.editcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_editcomponent(
    ::EditComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_editcomponent();
    _impl_.payload_.editcomponent_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.editComponent)
}
inline ::EditComponent* PROTOBUF_NONNULL ApiRequest::_internal_mutable_editcomponent() {
  if (payload_case() != kEditComponent) {
    clear_payload();
    set_has_editcomponent();
    _impl_.payload_.editcomponent_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::EditComponent>(GetArena()));
  }
  return reinterpret_cast<::EditComponent*>(_impl_.payload_.editcomponent_);
}
inline ::EditComponent* PROTOBUF_NONNULL ApiRequest::mutable_editcomponent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::EditComponent* _msg = _internal_mutable_editcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.editComponent)
  return _msg;
}

// .CreateEntity createEntity = 15;
inline bool ApiRequest::has_createentity() const {
  return payload_case() == kCreateEntity;
}
inline bool ApiRequest::_internal_has_createentity() const {
  return payload_case() == kCreateEntity;
}
inline void ApiRequest::set_has_createentity() {
  _impl_._oneof_case_[0] = kCreateEntity;
}
inline void ApiRequest::clear_createentity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCreateEntity) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.createentity_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.createentity_);
    }
    clear_has_payload();
  }
}
inline ::CreateEntity* PROTOBUF_NULLABLE ApiRequest::release_createentity() {
  // @@protoc_insertion_point(field_release:ApiRequest.createEntity)
  if (payload_case() == kCreateEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::CreateEntity*>(_impl_.payload_.createentity_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.createentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CreateEntity& ApiRequest::_internal_createentity() const {
  return payload_case() == kCreateEntity ? static_cast<const ::CreateEntity&>(*reinterpret_cast<::CreateEntity*>(_impl_.payload_.createentity_))
                     : reinterpret_cast<const ::CreateEntity&>(::_CreateEntity_default_instance_);
}
inline const ::CreateEntity& ApiRequest::createentity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.createEntity)
  return _internal_createentity();
}
inline ::CreateEntity* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_createentity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.createEntity)
  if (payload_case() == kCreateEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::CreateEntity*>(_impl_.payload_.createentity_);
    _impl_.payload_.createentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_createentity(
    ::CreateEntity* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_createentity();
    _impl_.payload_.createentity_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.createEntity)
}
inline ::CreateEntity* PROTOBUF_NONNULL ApiRequest::_internal_mutable_createentity() {
  if (payload_case() != kCreateEntity) {
    clear_payload();
    set_has_createentity();
    _impl_.payload_.createentity_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::CreateEntity>(GetArena()));
  }
  return reinterpret_cast<::CreateEntity*>(_impl_.payload_.createentity_);
}
inline ::CreateEntity* PROTOBUF_NONNULL ApiRequest::mutable_createentity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CreateEntity* _msg = _internal_mutable_createentity();
  // @@protoc_insertion_point(field_mutable:ApiRequest.createEntity)
  return _msg;
}

// .DeleteEntity deleteEntity = 16;
inline bool ApiRequest::has_deleteentity() const {
  return payload_case() == kDeleteEntity;
}
inline bool ApiRequest::_internal_has_deleteentity() const {
  return payload_case() == kDeleteEntity;
}
inline void ApiRequest::set_has_deleteentity() {
  _impl_._oneof_case_[0] = kDeleteEntity;
}
inline void ApiRequest::clear_deleteentity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteEntity) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.deleteentity_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.deleteentity_);
    }
    clear_has_payload();
  }
}
inline ::DeleteEntity* PROTOBUF_NULLABLE ApiRequest::release_deleteentity() {
  // @@protoc_insertion_point(field_release:ApiRequest.deleteEntity)
  if (payload_case() == kDeleteEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::DeleteEntity*>(_impl_.payload_.deleteentity_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deleteentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::DeleteEntity& ApiRequest::_internal_deleteentity() const {
  return payload_case() == kDeleteEntity ? static_cast<const ::DeleteEntity&>(*reinterpret_cast<::DeleteEntity*>(_impl_.payload_.deleteentity_))
                     : reinterpret_cast<const ::DeleteEntity&>(::_DeleteEntity_default_instance_);
}
inline const ::DeleteEntity& ApiRequest::deleteentity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.deleteEntity)
  return _internal_deleteentity();
}
inline ::DeleteEntity* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_deleteentity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.deleteEntity)
  if (payload_case() == kDeleteEntity) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::DeleteEntity*>(_impl_.payload_.deleteentity_);
    _impl_.payload_.deleteentity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_deleteentity(
    ::DeleteEntity* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_deleteentity();
    _impl_.payload_.deleteentity_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.deleteEntity)
}
inline ::DeleteEntity* PROTOBUF_NONNULL ApiRequest::_internal_mutable_deleteentity() {
  if (payload_case() != kDeleteEntity) {
    clear_payload();
    set_has_deleteentity();
    _impl_.payload_.deleteentity_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::DeleteEntity>(GetArena()));
  }
  return reinterpret_cast<::DeleteEntity*>(_impl_.payload_.deleteentity_);
}
inline ::DeleteEntity* PROTOBUF_NONNULL ApiRequest::mutable_deleteentity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::DeleteEntity* _msg = _internal_mutable_deleteentity();
  // @@protoc_insertion_point(field_mutable:ApiRequest.deleteEntity)
  return _msg;
}

// .ListEntities listEntities = 17;
inline bool ApiRequest::has_listentities() const {
  return payload_case() == kListEntities;
}
inline bool ApiRequest::_internal_has_listentities() const {
  return payload_case() == kListEntities;
}
inline void ApiRequest::set_has_listentities() {
  _impl_._oneof_case_[0] = kListEntities;
}
inline void ApiRequest::clear_listentities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kListEntities) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.listentities_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.listentities_);
    }
    clear_has_payload();
  }
}
inline ::ListEntities* PROTOBUF_NULLABLE ApiRequest::release_listentities() {
  // @@protoc_insertion_point(field_release:ApiRequest.listEntities)
  if (payload_case() == kListEntities) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ListEntities*>(_impl_.payload_.listentities_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.listentities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ListEntities& ApiRequest::_internal_listentities() const {
  return payload_case() == kListEntities ? static_cast<const ::ListEntities&>(*reinterpret_cast<::ListEntities*>(_impl_.payload_.listentities_))
                     : reinterpret_cast<const ::ListEntities&>(::_ListEntities_default_instance_);
}
inline const ::ListEntities& ApiRequest::listentities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.listEntities)
  return _internal_listentities();
}
inline ::ListEntities* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_listentities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.listEntities)
  if (payload_case() == kListEntities) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::ListEntities*>(_impl_.payload_.listentities_);
    _impl_.payload_.listentities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_listentities(
    ::ListEntities* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_listentities();
    _impl_.payload_.listentities_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.listEntities)
}
inline ::ListEntities* PROTOBUF_NONNULL ApiRequest::_internal_mutable_listentities() {
  if (payload_case() != kListEntities) {
    clear_payload();
    set_has_listentities();
    _impl_.payload_.listentities_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::ListEntities>(GetArena()));
  }
  return reinterpret_cast<::ListEntities*>(_impl_.payload_.listentities_);
}
inline ::ListEntities* PROTOBUF_NONNULL ApiRequest::mutable_listentities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ListEntities* _msg = _internal_mutable_listentities();
  // @@protoc_insertion_point(field_mutable:ApiRequest.listEntities)
  return _msg;
}

// .GetComponent getComponent = 18;
inline bool ApiRequest::has_getcomponent() const {
  return payload_case() == kGetComponent;
}
inline bool ApiRequest::_internal_has_getcomponent() const {
  return payload_case() == kGetComponent;
}
inline void ApiRequest::set_has_getcomponent() {
  _impl_._oneof_case_[0] = kGetComponent;
}
inline void ApiRequest::clear_getcomponent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetComponent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.getcomponent_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.getcomponent_);
    }
    clear_has_payload();
  }
}
inline ::GetComponent* PROTOBUF_NULLABLE ApiRequest::release_getcomponent() {
  // @@protoc_insertion_point(field_release:ApiRequest.getComponent)
  if (payload_case() == kGetComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::GetComponent*>(_impl_.payload_.getcomponent_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.getcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetComponent& ApiRequest::_internal_getcomponent() const {
  return payload_case() == kGetComponent ? static_cast<const ::GetComponent&>(*reinterpret_cast<::GetComponent*>(_impl_.payload_.getcomponent_))
                     : reinterpret_cast<const ::GetComponent&>(::_GetComponent_default_instance_);
}
inline const ::GetComponent& ApiRequest::getcomponent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequest.getComponent)
  return _internal_getcomponent();
}
inline ::GetComponent* PROTOBUF_NULLABLE ApiRequest::unsafe_arena_release_getcomponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApiRequest.getComponent)
  if (payload_case() == kGetComponent) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::GetComponent*>(_impl_.payload_.getcomponent_);
    _impl_.payload_.getcomponent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApiRequest::unsafe_arena_set_allocated_getcomponent(
    ::GetComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_getcomponent();
    _impl_.payload_.getcomponent_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequest.getComponent)
}
inline ::GetComponent* PROTOBUF_NONNULL ApiRequest::_internal_mutable_getcomponent() {
  if (payload_case() != kGetComponent) {
    clear_payload();
    set_has_getcomponent();
    _impl_.payload_.getcomponent_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::GetComponent>(GetArena()));
  }
  return reinterpret_cast<::GetComponent*>(_impl_.payload_.getcomponent_);
}
inline ::GetComponent* PROTOBUF_NONNULL ApiRequest::mutable_getcomponent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetComponent* _msg = _internal_mutable_getcomponent();
  // @@protoc_insertion_point(field_mutable:ApiRequest.getComponent)
  return _msg;
}

inline bool ApiRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ApiRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ApiRequest::PayloadCase ApiRequest::payload_case() const {
  return ApiRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ApiRequestResponse

// int64 requestId = 1;
inline void ApiRequestResponse::clear_requestid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int64_t ApiRequestResponse::requestid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.requestId)
  return _internal_requestid();
}
inline void ApiRequestResponse::set_requestid(::int64_t value) {
  _internal_set_requestid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.requestId)
}
inline ::int64_t ApiRequestResponse::_internal_requestid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requestid_;
}
inline void ApiRequestResponse::_internal_set_requestid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requestid_ = value;
}

// int64 actionId = 2;
inline void ApiRequestResponse::clear_actionid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int64_t ApiRequestResponse::actionid() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.actionId)
  return _internal_actionid();
}
inline void ApiRequestResponse::set_actionid(::int64_t value) {
  _internal_set_actionid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.actionId)
}
inline ::int64_t ApiRequestResponse::_internal_actionid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actionid_;
}
inline void ApiRequestResponse::_internal_set_actionid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actionid_ = value;
}

// bool success = 3;
inline void ApiRequestResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline bool ApiRequestResponse::success() const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.success)
  return _internal_success();
}
inline void ApiRequestResponse::set_success(bool value) {
  _internal_set_success(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.success)
}
inline bool ApiRequestResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ApiRequestResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .EngineStatus status = 4;
inline bool ApiRequestResponse::has_status() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ApiRequestResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::EngineStatus& ApiRequestResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::EngineStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::EngineStatus&>(::_EngineStatus_default_instance_);
}
inline const ::EngineStatus& ApiRequestResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.status)
  return _internal_status();
}
inline void ApiRequestResponse::unsafe_arena_set_allocated_status(
    ::EngineStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequestResponse.status)
}
inline ::EngineStatus* PROTOBUF_NULLABLE ApiRequestResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::EngineStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::EngineStatus* PROTOBUF_NULLABLE ApiRequestResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApiRequestResponse.status)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::EngineStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::EngineStatus* PROTOBUF_NONNULL ApiRequestResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::EngineStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::EngineStatus*>(p);
  }
  return _impl_.status_;
}
inline ::EngineStatus* PROTOBUF_NONNULL ApiRequestResponse::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::EngineStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.status)
  return _msg;
}
inline void ApiRequestResponse::set_allocated_status(::EngineStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.status_ = reinterpret_cast<::EngineStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApiRequestResponse.status)
}

// repeated int64 entity_ids = 5;
inline int ApiRequestResponse::_internal_entity_ids_size() const {
  return _internal_entity_ids().size();
}
inline int ApiRequestResponse::entity_ids_size() const {
  return _internal_entity_ids_size();
}
inline void ApiRequestResponse::clear_entity_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_ids_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t ApiRequestResponse::entity_ids(int index) const {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.entity_ids)
  return _internal_entity_ids().Get(index);
}
inline void ApiRequestResponse::set_entity_ids(int index, ::int64_t value) {
  _internal_mutable_entity_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:ApiRequestResponse.entity_ids)
}
inline void ApiRequestResponse::add_entity_ids(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_entity_ids()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:ApiRequestResponse.entity_ids)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& ApiRequestResponse::entity_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ApiRequestResponse.entity_ids)
  return _internal_entity_ids();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL ApiRequestResponse::mutable_entity_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:ApiRequestResponse.entity_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_ids();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
ApiRequestResponse::_internal_entity_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_ids_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
ApiRequestResponse::_internal_mutable_entity_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_ids_;
}

// .Component component = 6;
inline bool ApiRequestResponse::has_component() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void ApiRequestResponse::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::Component& ApiRequestResponse::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& ApiRequestResponse::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.component)
  return _internal_component();
}
inline void ApiRequestResponse::unsafe_arena_set_allocated_component(
    ::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApiRequestResponse.component)
}
inline ::Component* PROTOBUF_NULLABLE ApiRequestResponse::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Component* PROTOBUF_NULLABLE ApiRequestResponse::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApiRequestResponse.component)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* PROTOBUF_NONNULL ApiRequestResponse::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* PROTOBUF_NONNULL ApiRequestResponse::mutable_component()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.component)
  return _msg;
}
inline void ApiRequestResponse::set_allocated_component(::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApiRequestResponse.component)
}

// repeated .EntityComponentInfo entity_components = 7;
inline int ApiRequestResponse::_internal_entity_components_size() const {
  return _internal_entity_components().size();
}
inline int ApiRequestResponse::entity_components_size() const {
  return _internal_entity_components_size();
}
inline void ApiRequestResponse::clear_entity_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_components_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::EntityComponentInfo* PROTOBUF_NONNULL ApiRequestResponse::mutable_entity_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ApiRequestResponse.entity_components)
  return _internal_mutable_entity_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* PROTOBUF_NONNULL ApiRequestResponse::mutable_entity_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:ApiRequestResponse.entity_components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity_components();
}
inline const ::EntityComponentInfo& ApiRequestResponse::entity_components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApiRequestResponse.entity_components)
  return _internal_entity_components().Get(index);
}
inline ::EntityComponentInfo* PROTOBUF_NONNULL ApiRequestResponse::add_entity_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::EntityComponentInfo* _add =
      _internal_mutable_entity_components()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:ApiRequestResponse.entity_components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>& ApiRequestResponse::entity_components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ApiRequestResponse.entity_components)
  return _internal_entity_components();
}
inline const ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>&
ApiRequestResponse::_internal_entity_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_components_;
}
inline ::google::protobuf::RepeatedPtrField<::EntityComponentInfo>* PROTOBUF_NONNULL
ApiRequestResponse::_internal_mutable_entity_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_components_;
}

// -------------------------------------------------------------------

// EntityComponentInfo

// int64 entity_id = 1;
inline void EntityComponentInfo::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t EntityComponentInfo::entity_id() const {
  // @@protoc_insertion_point(field_get:EntityComponentInfo.entity_id)
  return _internal_entity_id();
}
inline void EntityComponentInfo::set_entity_id(::int64_t value) {
  _internal_set_entity_id(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:EntityComponentInfo.entity_id)
}
inline ::int64_t EntityComponentInfo::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_;
}
inline void EntityComponentInfo::_internal_set_entity_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_ = value;
}

// repeated .ComponentType component_types = 2;
inline int EntityComponentInfo::_internal_component_types_size() const {
  return _internal_component_types().size();
}
inline int EntityComponentInfo::component_types_size() const {
  return _internal_component_types_size();
}
inline void EntityComponentInfo::clear_component_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_types_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ComponentType EntityComponentInfo::component_types(int index) const {
  // @@protoc_insertion_point(field_get:EntityComponentInfo.component_types)
  return static_cast<::ComponentType>(_internal_component_types().Get(index));
}
inline void EntityComponentInfo::set_component_types(int index, ::ComponentType value) {
  _internal_mutable_component_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:EntityComponentInfo.component_types)
}
inline void EntityComponentInfo::add_component_types(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_component_types()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:EntityComponentInfo.component_types)
}
inline const ::google::protobuf::RepeatedField<int>& EntityComponentInfo::component_types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:EntityComponentInfo.component_types)
  return _internal_component_types();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL EntityComponentInfo::mutable_component_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:EntityComponentInfo.component_types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_component_types();
}
inline const ::google::protobuf::RepeatedField<int>& EntityComponentInfo::_internal_component_types()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_types_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
EntityComponentInfo::_internal_mutable_component_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.component_types_;
}

// -------------------------------------------------------------------

// PositionableComponent

// int64 entityId = 1;
inline void PositionableComponent::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int64_t PositionableComponent::entityid() const {
  // @@protoc_insertion_point(field_get:PositionableComponent.entityId)
  return _internal_entityid();
}
inline void PositionableComponent::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:PositionableComponent.entityId)
}
inline ::int64_t PositionableComponent::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void PositionableComponent::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// .Vector position = 2;
inline bool PositionableComponent::has_position() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Vector& PositionableComponent::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.position)
  return _internal_position();
}
inline void PositionableComponent::unsafe_arena_set_allocated_position(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.position)
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.position)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.position_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.position_;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Vector* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.position)
  return _msg;
}
inline void PositionableComponent::set_allocated_position(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.position_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.position)
}

// .Vector rotation = 3;
inline bool PositionableComponent::has_rotation() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::Vector& PositionableComponent::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.rotation)
  return _internal_rotation();
}
inline void PositionableComponent::unsafe_arena_set_allocated_rotation(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.rotation)
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.rotation)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.rotation_;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::mutable_rotation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::Vector* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.rotation)
  return _msg;
}
inline void PositionableComponent::set_allocated_rotation(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.rotation_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.rotation)
}

// float scale = 4;
inline void PositionableComponent::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline float PositionableComponent::scale() const {
  // @@protoc_insertion_point(field_get:PositionableComponent.scale)
  return _internal_scale();
}
inline void PositionableComponent::set_scale(float value) {
  _internal_set_scale(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:PositionableComponent.scale)
}
inline float PositionableComponent::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scale_;
}
inline void PositionableComponent::_internal_set_scale(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = value;
}

// .Vector origin = 5;
inline bool PositionableComponent::has_origin() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline void PositionableComponent::clear_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::Vector& PositionableComponent::_internal_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Vector* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector&>(::_Vector_default_instance_);
}
inline const ::Vector& PositionableComponent::origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PositionableComponent.origin)
  return _internal_origin();
}
inline void PositionableComponent::unsafe_arena_set_allocated_origin(
    ::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = reinterpret_cast<::Vector*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PositionableComponent.origin)
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Vector* released = _impl_.origin_;
  _impl_.origin_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Vector* PROTOBUF_NULLABLE PositionableComponent::unsafe_arena_release_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PositionableComponent.origin)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Vector* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::_internal_mutable_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Vector>(GetArena());
    _impl_.origin_ = reinterpret_cast<::Vector*>(p);
  }
  return _impl_.origin_;
}
inline ::Vector* PROTOBUF_NONNULL PositionableComponent::mutable_origin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::Vector* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:PositionableComponent.origin)
  return _msg;
}
inline void PositionableComponent::set_allocated_origin(::Vector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.origin_ = reinterpret_cast<::Vector*>(value);
  // @@protoc_insertion_point(field_set_allocated:PositionableComponent.origin)
}

// -------------------------------------------------------------------

// ModelComponent

// int64 entityId = 1;
inline void ModelComponent::clear_entityid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t ModelComponent::entityid() const {
  // @@protoc_insertion_point(field_get:ModelComponent.entityId)
  return _internal_entityid();
}
inline void ModelComponent::set_entityid(::int64_t value) {
  _internal_set_entityid(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:ModelComponent.entityId)
}
inline ::int64_t ModelComponent::_internal_entityid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entityid_;
}
inline void ModelComponent::_internal_set_entityid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entityid_ = value;
}

// string model_path = 2;
inline void ModelComponent::clear_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ModelComponent::model_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ModelComponent.model_path)
  return _internal_model_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ModelComponent::set_model_path(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.model_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ModelComponent.model_path)
}
inline ::std::string* PROTOBUF_NONNULL ModelComponent::mutable_model_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_model_path();
  // @@protoc_insertion_point(field_mutable:ModelComponent.model_path)
  return _s;
}
inline const ::std::string& ModelComponent::_internal_model_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_path_.Get();
}
inline void ModelComponent::_internal_set_model_path(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_path_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ModelComponent::_internal_mutable_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_path_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ModelComponent::release_model_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ModelComponent.model_path)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.model_path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_path_.Set("", GetArena());
  }
  return released;
}
inline void ModelComponent::set_allocated_model_path(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.model_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_path_.IsDefault()) {
    _impl_.model_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ModelComponent.model_path)
}

// -------------------------------------------------------------------

// Component

// .ComponentType type = 1;
inline void Component::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ComponentType Component::type() const {
  // @@protoc_insertion_point(field_get:Component.type)
  return _internal_type();
}
inline void Component::set_type(::ComponentType value) {
  _internal_set_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:Component.type)
}
inline ::ComponentType Component::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.type_);
}
inline void Component::_internal_set_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .PositionableComponent positionable = 2;
inline bool Component::has_positionable() const {
  return component_type_case() == kPositionable;
}
inline bool Component::_internal_has_positionable() const {
  return component_type_case() == kPositionable;
}
inline void Component::set_has_positionable() {
  _impl_._oneof_case_[0] = kPositionable;
}
inline void Component::clear_positionable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (component_type_case() == kPositionable) {
    if (GetArena() == nullptr) {
      delete _impl_.component_type_.positionable_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.component_type_.positionable_);
    }
    clear_has_component_type();
  }
}
inline ::PositionableComponent* PROTOBUF_NULLABLE Component::release_positionable() {
  // @@protoc_insertion_point(field_release:Component.positionable)
  if (component_type_case() == kPositionable) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.positionable_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.component_type_.positionable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PositionableComponent& Component::_internal_positionable() const {
  return component_type_case() == kPositionable ? static_cast<const ::PositionableComponent&>(*_impl_.component_type_.positionable_)
                     : reinterpret_cast<const ::PositionableComponent&>(::_PositionableComponent_default_instance_);
}
inline const ::PositionableComponent& Component::positionable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Component.positionable)
  return _internal_positionable();
}
inline ::PositionableComponent* PROTOBUF_NULLABLE Component::unsafe_arena_release_positionable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Component.positionable)
  if (component_type_case() == kPositionable) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.positionable_;
    _impl_.component_type_.positionable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Component::unsafe_arena_set_allocated_positionable(
    ::PositionableComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_component_type();
  if (value) {
    set_has_positionable();
    _impl_.component_type_.positionable_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Component.positionable)
}
inline ::PositionableComponent* PROTOBUF_NONNULL Component::_internal_mutable_positionable() {
  if (component_type_case() != kPositionable) {
    clear_component_type();
    set_has_positionable();
    _impl_.component_type_.positionable_ = 
        ::google::protobuf::Message::DefaultConstruct<::PositionableComponent>(GetArena());
  }
  return _impl_.component_type_.positionable_;
}
inline ::PositionableComponent* PROTOBUF_NONNULL Component::mutable_positionable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PositionableComponent* _msg = _internal_mutable_positionable();
  // @@protoc_insertion_point(field_mutable:Component.positionable)
  return _msg;
}

// .ModelComponent model = 3;
inline bool Component::has_model() const {
  return component_type_case() == kModel;
}
inline bool Component::_internal_has_model() const {
  return component_type_case() == kModel;
}
inline void Component::set_has_model() {
  _impl_._oneof_case_[0] = kModel;
}
inline void Component::clear_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (component_type_case() == kModel) {
    if (GetArena() == nullptr) {
      delete _impl_.component_type_.model_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.component_type_.model_);
    }
    clear_has_component_type();
  }
}
inline ::ModelComponent* PROTOBUF_NULLABLE Component::release_model() {
  // @@protoc_insertion_point(field_release:Component.model)
  if (component_type_case() == kModel) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.model_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.component_type_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ModelComponent& Component::_internal_model() const {
  return component_type_case() == kModel ? static_cast<const ::ModelComponent&>(*_impl_.component_type_.model_)
                     : reinterpret_cast<const ::ModelComponent&>(::_ModelComponent_default_instance_);
}
inline const ::ModelComponent& Component::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Component.model)
  return _internal_model();
}
inline ::ModelComponent* PROTOBUF_NULLABLE Component::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Component.model)
  if (component_type_case() == kModel) {
    clear_has_component_type();
    auto* temp = _impl_.component_type_.model_;
    _impl_.component_type_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Component::unsafe_arena_set_allocated_model(
    ::ModelComponent* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_component_type();
  if (value) {
    set_has_model();
    _impl_.component_type_.model_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Component.model)
}
inline ::ModelComponent* PROTOBUF_NONNULL Component::_internal_mutable_model() {
  if (component_type_case() != kModel) {
    clear_component_type();
    set_has_model();
    _impl_.component_type_.model_ = 
        ::google::protobuf::Message::DefaultConstruct<::ModelComponent>(GetArena());
  }
  return _impl_.component_type_.model_;
}
inline ::ModelComponent* PROTOBUF_NONNULL Component::mutable_model()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ModelComponent* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:Component.model)
  return _msg;
}

inline bool Component::has_component_type() const {
  return component_type_case() != COMPONENT_TYPE_NOT_SET;
}
inline void Component::clear_has_component_type() {
  _impl_._oneof_case_[0] = COMPONENT_TYPE_NOT_SET;
}
inline Component::ComponentTypeCase Component::component_type_case() const {
  return Component::ComponentTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddComponent

// .Component component = 1;
inline bool AddComponent::has_component() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void AddComponent::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Component& AddComponent::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& AddComponent::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AddComponent.component)
  return _internal_component();
}
inline void AddComponent::unsafe_arena_set_allocated_component(
    ::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AddComponent.component)
}
inline ::Component* PROTOBUF_NULLABLE AddComponent::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Component* PROTOBUF_NULLABLE AddComponent::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AddComponent.component)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* PROTOBUF_NONNULL AddComponent::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* PROTOBUF_NONNULL AddComponent::mutable_component()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:AddComponent.component)
  return _msg;
}
inline void AddComponent::set_allocated_component(::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:AddComponent.component)
}

// -------------------------------------------------------------------

// DeleteComponent

// .ComponentType component_type = 1;
inline void DeleteComponent::clear_component_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::ComponentType DeleteComponent::component_type() const {
  // @@protoc_insertion_point(field_get:DeleteComponent.component_type)
  return _internal_component_type();
}
inline void DeleteComponent::set_component_type(::ComponentType value) {
  _internal_set_component_type(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:DeleteComponent.component_type)
}
inline ::ComponentType DeleteComponent::_internal_component_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ComponentType>(_impl_.component_type_);
}
inline void DeleteComponent::_internal_set_component_type(::ComponentType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_type_ = value;
}

// -------------------------------------------------------------------

// EditComponent

// .Component component = 1;
inline bool EditComponent::has_component() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.component_ != nullptr);
  return value;
}
inline void EditComponent::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ != nullptr) _impl_.component_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::Component& EditComponent::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Component* p = _impl_.component_;
  return p != nullptr ? *p : reinterpret_cast<const ::Component&>(::_Component_default_instance_);
}
inline const ::Component& EditComponent::component() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:EditComponent.component)
  return _internal_component();
}
inline void EditComponent::unsafe_arena_set_allocated_component(
    ::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }
  _impl_.component_ = reinterpret_cast<::Component*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EditComponent.component)
}
inline ::Component* PROTOBUF_NULLABLE EditComponent::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* released = _impl_.component_;
  _impl_.component_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Component* PROTOBUF_NULLABLE EditComponent::unsafe_arena_release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:EditComponent.component)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* temp = _impl_.component_;
  _impl_.component_ = nullptr;
  return temp;
}
inline ::Component* PROTOBUF_NONNULL EditComponent::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.component_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Component>(GetArena());
    _impl_.component_ = reinterpret_cast<::Component*>(p);
  }
  return _impl_.component_;
}
inline ::Component* PROTOBUF_NONNULL EditComponent::mutable_component()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::Component* _msg = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:EditComponent.component)
  return _msg;
}
inline void EditComponent::set_allocated_component(::Component* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.component_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.component_ = reinterpret_cast<::Component*>(value);
  // @@protoc_insertion_point(field_set_allocated:EditComponent.component)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::MessageType>() {
  return ::MessageType_descriptor();
}
template <>
struct is_proto_enum<::ComponentType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::ComponentType>() {
  return ::ComponentType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // protos_2fapi_2eproto_2epb_2eh
